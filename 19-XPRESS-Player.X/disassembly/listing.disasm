Disassembly Listing for WAVPlayer
Generated From:
/Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/dist/default/debug/19-WAVPlayer.X.debug.elf
22-Nov-2016 15:15:17

---  /Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/mcc_generated_files/tmr2.c
1:             /**
2:               TMR2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR2 driver using MPLAB(c) Code Configurator
12:            
13:              @Description
14:                This source file provides APIs for TMR2.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 3.15.0
17:                    Device            :  PIC16F18855
18:                    Driver Version    :  1.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.20
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:             */
45:            
46:            /**
47:              Section: Included Files
48:            */
49:            
50:            #include <xc.h>
51:            #include "tmr2.h"
52:            
53:            
54:            /**
55:              Section: TMR2 APIs
56:            */
57:            
58:            void TMR2_Initialize(void)
59:            {
60:                // Set TMR2 to the options selected in the User Interface
61:            
62:                // T2CKPS 1:1; T2OUTPS 1:1; TMR2ON on; 
63:                T2CON = 0x00;
0A0B  0025     MOVLB 0x5
0A0C  018E     CLRF T2CON
64:            
65:                // T2CS FOSC/4; 
66:                T2CLKCON = 0x01;
0A0D  3001     MOVLW 0x1
0A0E  0090     MOVWF T2CLK
67:            
68:                // T2PSYNC Not Synchronized; T2MODE Software control; T2CKPOL Rising Edge; T2CKSYNC Not Synchronized; 
69:                T2HLT = 0x00;
0A0F  018F     CLRF T2HLT
70:            
71:                // T2RSEL T2CKIPPS pin; 
72:                T2RST = 0x00;
0A10  0191     CLRF T2RST
73:            
74:                // PR2 176; 
75:                T2PR = 0xB0;
0A11  30B0     MOVLW 0xB0
0A12  008D     MOVWF T2PR
76:            
77:                // TMR2 0; 
78:                T2TMR = 0x00;
0A13  018C     CLRF T2TMR
79:            
80:                // Clearing IF flag before enabling the interrupt.
81:                PIR4bits.TMR2IF = 0;
0A14  002E     MOVLB 0xE
0A15  1090     BCF PIR4, 0x1
82:            
83:                // Enabling TMR2 interrupt.
84:                PIE4bits.TMR2IE = 1;
0A16  149A     BSF PIE4, 0x1
85:            
86:                // Set Default Interrupt Handler
87:                TMR2_SetInterruptHandler(TMR2_DefaultInterruptHandler);
0A17  30C6     MOVLW 0xC6
0A18  00F3     MOVWF 0x773
0A19  3005     MOVLW 0x5
0A1A  00F4     MOVWF 0x774
0A1B  27F2     CALL 0x7F2
0A1C  3188     MOVLP 0x8
88:            
89:                // Start TMR2
90:                TMR2_Start();
0A1D  2FFC     GOTO 0x7FC
91:            }
92:            
93:            void TMR2_ModeSet(TMR2_HLT_MODE mode)
94:            {
95:               // Configure different types HLT mode
96:                T2HLTbits.MODE = mode;
97:            }
98:            
99:            void TMR2_ExtResetSourceSet(TMR2_HLT_EXT_RESET_SOURCE reset)
100:           {
101:               //Configure different types of HLT external reset source
102:               T2RSTbits.RSEL = reset;
103:           }
104:           
105:           void TMR2_Start(void)
106:           {
107:               // Start the Timer by writing to TMRxON bit
108:               T2CONbits.TMR2ON = 1;
0FFC  0025     MOVLB 0x5
0FFD  178E     BSF T2CON, 0x7
109:           }
0FFE  0008     RETURN
110:           
111:           void TMR2_StartTimer(void)
112:           {
113:               TMR2_Start();
0FFF  2FFC     GOTO 0x7FC
114:           }
115:           
116:           void TMR2_Stop(void)
117:           {
118:               // Stop the Timer by writing to TMRxON bit
119:               T2CONbits.TMR2ON = 0;
0FF9  0025     MOVLB 0x5
0FFA  138E     BCF T2CON, 0x7
120:           }
0FFB  0008     RETURN
121:           
122:           void TMR2_StopTimer(void)
123:           {
124:               TMR2_Stop();
0FF8  2FF9     GOTO 0x7F9
125:           }
126:           
127:           uint8_t TMR2_Counter8BitGet(void)
128:           {
129:               uint8_t readVal;
130:           
131:               readVal = TMR2;
132:           
133:               return readVal;
134:           }
135:           
136:           uint8_t TMR2_ReadTimer(void)
137:           {
138:               return TMR2_Counter8BitGet();
139:           }
140:           
141:           void TMR2_Counter8BitSet(uint8_t timerVal)
142:           {
143:               // Write to the Timer2 register
144:               TMR2 = timerVal;
145:           }
146:           
147:           void TMR2_WriteTimer(uint8_t timerVal)
148:           {
149:               TMR2_Counter8BitSet(timerVal);
150:           }
151:           
152:           void TMR2_Period8BitSet(uint8_t periodVal)
153:           {
154:              PR2 = periodVal;
155:           }
156:           
157:           void TMR2_LoadPeriodRegister(uint8_t periodVal)
158:           {
159:              TMR2_Period8BitSet(periodVal);
160:           }
161:           
162:           void TMR2_ISR(void)
163:           {
164:           
165:               // clear the TMR2 interrupt flag
166:               PIR4bits.TMR2IF = 0;
0599  002E     MOVLB 0xE
059A  1090     BCF PIR4, 0x1
167:           
168:               if(TMR2_InterruptHandler)
059B  0021     MOVLB 0x1
059C  085D     MOVF TMR2_InterruptHandler, W
059D  045E     IORWF 0xDE, W
059E  1903     BTFSC 0x83, 0x2
059F  0008     RETURN
169:               {
170:                   TMR2_InterruptHandler();
05A0  085E     MOVF 0xDE, W
05A1  008A     MOVWF 0x8A
05A2  085D     MOVF TMR2_InterruptHandler, W
05A3  000A     CALLW
05A4  3185     MOVLP 0x5
171:               }
172:           }
05A5  0008     RETURN
173:           
174:           
175:           void TMR2_SetInterruptHandler(void* InterruptHandler){
176:               TMR2_InterruptHandler = InterruptHandler;
0FF2  0874     MOVF 0xF4, W
0FF3  0021     MOVLB 0x1
0FF4  00DE     MOVWF 0xDE
0FF5  0873     MOVF 0xF3, W
0FF6  00DD     MOVWF TMR2_InterruptHandler
177:           }
0FF7  0008     RETURN
178:           
179:           void TMR2_DefaultInterruptHandler(void){
180:               // add your TMR2 interrupt custom code
181:               // or set custom function using TMR2_SetInterruptHandler()
182:           }
05C6  0008     RETURN
183:           
184:           /**
185:             End of File
186:           */
---  /Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/mcc_generated_files/spi1.c
1:             /**
2:               MSSP1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 spi1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the MSSP1 driver using MPLAB(c) Code Configurator
12:            
13:              @Description
14:                This source file provides APIs for MSSP1.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 3.15.0
17:                    Device            :  PIC16F18855
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.20
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:             */
45:            
46:            /**
47:              Section: Included Files
48:            */
49:            
50:            #include <xc.h>
51:            #include "spi1.h"
52:            
53:            /**
54:              Section: Macro Declarations
55:            */
56:            
57:            #define SPI_RX_IN_PROGRESS 0x0
58:            
59:            /**
60:              Section: Module APIs
61:            */
62:            
63:            void SPI1_Initialize(void)
64:            {
65:                // Set the SPI1 module to the options selected in the User Interface
66:                
67:                // SMP Middle; CKE Active to Idle; 
68:                SSP1STAT = 0x40;
0A04  3040     MOVLW 0x40
0A05  0023     MOVLB 0x3
0A06  008F     MOVWF SSP1STAT
69:                
70:                // SSPEN enabled; CKP Idle:Low, Active:High; SSPM FOSC/4; 
71:                SSP1CON1 = 0x20;
0A07  3020     MOVLW 0x20
0A08  0090     MOVWF SSP1CON1
72:                
73:                // SSPADD 0; 
74:                SSP1ADD = 0x00;
0A09  018D     CLRF SSP1ADD
75:            }
0A0A  0008     RETURN
76:            
77:            void SPI1_InitializeSlow(void)
78:            {
79:                // Set the SPI1 module to start with a slow clock
80:                
81:                // SMP Middle; CKE Active to Idle; 
82:                SSP1STAT = 0x40;
0428  3040     MOVLW 0x40
0429  0023     MOVLB 0x3
042A  008F     MOVWF SSP1STAT
83:                
84:                // SSPEN enabled; CKP Idle:Low, Active:High; SSPM FOSC/4 / SSPADD; 
85:                SSP1CON1 = 0x2A;
042B  302A     MOVLW 0x2A
042C  0090     MOVWF SSP1CON1
86:                
87:                // SSPADD 39; 
88:                SSP1ADD = 0x27;
042D  3027     MOVLW 0x27
042E  008D     MOVWF SSP1ADD
89:            }
042F  0008     RETURN
90:            
91:            uint8_t SPI1_Exchange8bit(uint8_t data)
03FF  00F3     MOVWF 0x1F3
92:            {
93:                // Clear the Write Collision flag, to allow writing
94:                SSP1CON1bits.WCOL = 0;
0400  0023     MOVLB 0x3
0401  1390     BCF SSP1CON1, 0x7
95:            
96:                SSP1BUF = data;
0402  0873     MOVF 0x1F3, W
0403  008C     MOVWF SSP1BUF
97:            
98:                while(SSP1STATbits.BF == SPI_RX_IN_PROGRESS)
99:                {
100:               }
0404  1C0F     BTFSS SSP1STAT, 0x0
0405  2C04     GOTO 0x404
101:           
102:               return (SSP1BUF);
0406  080C     MOVF SSP1BUF, W
103:           }
0407  0008     RETURN
104:           
105:           uint8_t SPI1_Exchange8bitBuffer(uint8_t *dataIn, uint8_t bufLen, uint8_t *dataOut)
106:           {
107:               uint8_t bytesWritten = 0;
108:           
109:               if(bufLen != 0)
110:               {
111:                   if(dataIn != NULL)
112:                   {
113:                       while(bytesWritten < bufLen)
114:                       {
115:                           if(dataOut == NULL)
116:                           {
117:                               SPI1_Exchange8bit(dataIn[bytesWritten]);
118:                           }
119:                           else
120:                           {
121:                               dataOut[bytesWritten] = SPI1_Exchange8bit(dataIn[bytesWritten]);
122:                           }
123:           
124:                           bytesWritten++;
125:                       }
126:                   }
127:                   else
128:                   {
129:                       if(dataOut != NULL)
130:                       {
131:                           while(bytesWritten < bufLen )
132:                           {
133:                               dataOut[bytesWritten] = SPI1_Exchange8bit(DUMMY_DATA);
134:           
135:                               bytesWritten++;
136:                           }
137:                       }
138:                   }
139:               }
140:           
141:               return bytesWritten;
142:           }
143:           
144:           bool SPI1_IsBufferFull(void)
145:           {
146:               return (SSP1STATbits.BF);
147:           }
148:           
149:           bool SPI1_HasWriteCollisionOccured(void)
150:           {
151:               return (SSP1CON1bits.WCOL);
152:           }
153:           
154:           void SPI1_ClearWriteCollisionStatus(void)
155:           {
156:               SSP1CON1bits.WCOL = 0;
157:           }
158:           /**
159:            End of File
160:           */
---  /Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/mcc_generated_files/pwm7.c
1:              /**
2:                PWM7 Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  pwm7.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the PWM7 driver using MPLAB(c) Code Configurator
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for PWM7.
15:                 Generation Information :
16:                     Product Revision  :  MPLAB(c) Code Configurator - 3.15.0
17:                     Device            :  PIC16F18855
18:                     Driver Version    :  2.00
19:                 The generated drivers are tested against the following:
20:                     Compiler          :  XC8 1.35
21:                     MPLAB             :  MPLAB X 3.20
22:             */ 
23:            
24:             /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:             */
45:             
46:             /**
47:               Section: Included Files
48:             */
49:            
50:             #include <xc.h>
51:             #include "pwm7.h"
52:            
53:             /**
54:               Section: PWM Module APIs
55:             */
56:            
57:             void PWM7_Initialize(void)
58:             {
59:                 // Set the PWM to the options selected in the MPLAB(c) Code Configurator.
60:                 // PWM7POL active_hi; PWM7EN enabled; 
61:                 PWM7CON = 0x80;
09F7  3080     MOVLW 0x80
09F8  0027     MOVLB 0x7
09F9  0092     MOVWF PWM7CON
62:                 
63:                 // DC 88; 
64:                 PWM7DCH = 0x58;
09FA  3058     MOVLW 0x58
09FB  0091     MOVWF PWM7DCH
65:                 
66:                 // DC 1; 
67:                 PWM7DCL = 0x40;
09FC  3040     MOVLW 0x40
09FD  0090     MOVWF PWM7DCL
68:                 
69:                 
70:                 // Select timer
71:                 CCPTMRS1bits.P7TSEL = 0x1;
09FE  0024     MOVLB 0x4
09FF  081F     MOVF CCPTMRS1, W
0A00  39CF     ANDLW 0xCF
0A01  3810     IORLW 0x10
0A02  009F     MOVWF CCPTMRS1
72:             }
0A03  0008     RETURN
73:            
74:             void PWM7_LoadDutyValue(uint16_t dutyValue)
75:             {
76:                 // Writing to 8 MSBs of PWM duty cycle in PWMDCH register
77:                 PWM7DCH = (dutyValue & 0x03FC)>>2;
78:                 
79:                 // Writing to 2 LSBs of PWM duty cycle in PWMDCL register
80:                 PWM7DCL = (dutyValue & 0x0003)<<6;
81:             }
82:             /**
83:              End of File
84:             */
---  /Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/mcc_generated_files/pin_manager.c
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using MPLAB(c) Code Configurator
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 3.15.0
17:                    Device            :  PIC16F18855
18:                    Driver Version    :  1.02
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.20
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            
25:                Microchip licenses to you the right to use, modify, copy and distribute
26:                Software only when embedded on a Microchip microcontroller or digital signal
27:                controller that is integrated into your product or third party product
28:                (pursuant to the sublicense terms in the accompanying license agreement).
29:            
30:                You should refer to the license agreement accompanying this Software for
31:                additional information regarding your rights and obligations.
32:            
33:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:            
44:            */
45:            
46:            #include <xc.h>
47:            #include "pin_manager.h"
48:            #include <stdbool.h>
49:            
50:            void PIN_MANAGER_Initialize(void)
51:            {
52:                LATB = 0x4;
09AA  3004     MOVLW 0x4
09AB  0097     MOVWF T3CLK
53:                WPUE = 0x0;
09AC  003E     MOVLB 0x1E
09AD  01E5     CLRF WPUE
54:                LATA = 0x0;
09AE  0020     MOVLB 0x0
09AF  0196     CLRF LATA
55:                LATC = 0x1;
09B0  3001     MOVLW 0x1
09B1  0098     MOVWF LATC
56:                WPUA = 0x0;
09B2  003E     MOVLB 0x1E
09B3  01B9     CLRF WPUA
57:                WPUB = 0x0;
09B4  01C4     CLRF WPUB
58:                WPUC = 0x0;
09B5  01CF     CLRF WPUC
59:                ANSELA = 0xDF;
09B6  30DF     MOVLW 0xDF
09B7  00B8     MOVWF ANSELA
60:                ANSELB = 0xEE;
09B8  30EE     MOVLW 0xEE
09B9  00C3     MOVWF ANSELB
61:                ANSELC = 0xF5;
09BA  30F5     MOVLW 0xF5
09BB  00CE     MOVWF ANSELC
62:                TRISB = 0xD3;
09BC  30D3     MOVLW 0xD3
09BD  0020     MOVLB 0x0
09BE  0092     MOVWF TRISB
63:                TRISC = 0x5E;
09BF  305E     MOVLW 0x5E
09C0  0093     MOVWF TRISC
64:                TRISA = 0xF0;
09C1  30F0     MOVLW 0xF0
09C2  0091     MOVWF TRISA
65:            
66:                
67:            
68:            
69:                bool state = GIE;
09C3  3000     MOVLW 0x0
09C4  1B8B     BTFSC INTCON, 0x7
09C5  3001     MOVLW 0x1
09C6  00F3     MOVWF state
70:                GIE = 0;
09C7  138B     BCF INTCON, 0x7
71:                PPSLOCK = 0x55;
09C8  3055     MOVLW 0x55
09C9  003D     MOVLB 0x1D
09CA  008F     MOVWF PPSLOCK
72:                PPSLOCK = 0xAA;
09CB  30AA     MOVLW 0xAA
09CC  008F     MOVWF PPSLOCK
73:                PPSLOCKbits.PPSLOCKED = 0x00; // unlock PPS
09CD  100F     BCF PPSLOCK, 0x0
74:            
75:                T2AINPPSbits.T2AINPPS = 0x13;   //RC3->TMR2:T2IN;
09CE  081C     MOVF T2AINPPS, W
09CF  39E0     ANDLW 0xE0
09D0  3813     IORLW 0x13
09D1  009C     MOVWF T2AINPPS
76:                RC0PPS = 0x10;   //RC0->EUSART:TX;
09D2  3010     MOVLW 0x10
09D3  003E     MOVLB 0x1E
09D4  00A0     MOVWF RC0PPS
77:                SSP1DATPPSbits.SSP1DATPPS = 0x0C;   //RB4->MSSP1:SDI1;
09D5  003D     MOVLB 0x1D
09D6  0846     MOVF SSP1DATPPS, W
09D7  39E0     ANDLW 0xE0
09D8  380C     IORLW 0xC
09D9  00C6     MOVWF SSP1DATPPS
78:                RXPPSbits.RXPPS = 0x11;   //RC1->EUSART:RX;
09DA  084B     MOVF RXPPS, W
09DB  39E0     ANDLW 0xE0
09DC  3811     IORLW 0x11
09DD  00CB     MOVWF RXPPS
79:                RB5PPS = 0x15;   //RB5->MSSP1:SDO1;
09DE  3015     MOVLW 0x15
09DF  003E     MOVLB 0x1E
09E0  009D     MOVWF RB5PPS
80:                RB3PPS = 0x14;   //RB3->MSSP1:SCK1;
09E1  3014     MOVLW 0x14
09E2  009B     MOVWF RB3PPS
81:                RC5PPS = 0x06;   //RC5->CWG1:CWG1B;
09E3  3006     MOVLW 0x6
09E4  00A5     MOVWF RC5PPS
82:                RC7PPS = 0x0F;   //RC7->PWM7:PWM7OUT;
09E5  300F     MOVLW 0xF
09E6  00A7     MOVWF RC7PPS
83:                CWG1PPSbits.CWG1PPS = 0x08;   //RB0->CWG1:CWG1IN;
09E7  003D     MOVLB 0x1D
09E8  0831     MOVF CWG1PPS, W
09E9  39E0     ANDLW 0xE0
09EA  3808     IORLW 0x8
09EB  00B1     MOVWF CWG1PPS
84:            
85:                PPSLOCK = 0x55;
09EC  3055     MOVLW 0x55
09ED  008F     MOVWF PPSLOCK
86:                PPSLOCK = 0xAA;
09EE  30AA     MOVLW 0xAA
09EF  008F     MOVWF PPSLOCK
87:                PPSLOCKbits.PPSLOCKED = 0x01; // lock PPS
09F0  140F     BSF PPSLOCK, 0x0
88:            
89:                GIE = state;
09F1  1C73     BTFSS 0xEF3, 0x0
09F2  29F5     GOTO 0x1F5
09F3  178B     BSF 0xE8B, 0x7
09F4  0008     RETURN
09F5  138B     BCF 0xE8B, 0x7
90:            
91:            }
09F6  0008     RETURN
92:            
93:            
94:            void PIN_MANAGER_IOC(void)
95:            {    
96:            }
97:            
98:            /**
99:             End of File
100:           */
---  /Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/mcc_generated_files/mcc.c
1:             /**
2:               @Generated MPLAB(c) Code Configurator Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using MPLAB(c) Code Configurator
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 3.15.0
17:                    Device            :  PIC16F18855
18:                    Driver Version    :  1.02
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.20
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:            */
45:            
46:            // Configuration bits: selected in the GUI
47:            
48:            // CONFIG1
49:            #pragma config FEXTOSC = OFF    // External Oscillator mode selection bits->Oscillator not enabled
50:            #pragma config RSTOSC = HFINT32    // Power-up default value for COSC bits->HFINTOSC with OSCFRQ= 32 MHz and CDIV = 1:1
51:            #pragma config CLKOUTEN = OFF    // Clock Out Enable bit->CLKOUT function is disabled; i/o or oscillator function on OSC2
52:            #pragma config CSWEN = ON    // Clock Switch Enable bit->Writing to NOSC and NDIV is allowed
53:            #pragma config FCMEN = ON    // Fail-Safe Clock Monitor Enable bit->FSCM timer enabled
54:            
55:            // CONFIG2
56:            #pragma config MCLRE = ON    // Master Clear Enable bit->MCLR pin is Master Clear function
57:            #pragma config PWRTE = OFF    // Power-up Timer Enable bit->PWRT disabled
58:            #pragma config LPBOREN = OFF    // Low-Power BOR enable bit->ULPBOR disabled
59:            #pragma config BOREN = ON    // Brown-out reset enable bits->Brown-out Reset Enabled, SBOREN bit is ignored
60:            #pragma config BORV = LO    // Brown-out Reset Voltage Selection->Brown-out Reset Voltage (VBOR) set to 1.9V on LF, and 2.45V on F Devices
61:            #pragma config ZCD = ON    // Zero-cross detect disable->Zero-cross detect circuit is disabled at POR.
62:            #pragma config PPS1WAY = ON    // Peripheral Pin Select one-way control->The PPSLOCK bit can be cleared and set only once in software
63:            #pragma config STVREN = ON    // Stack Overflow/Underflow Reset Enable bit->Stack Overflow or Underflow will cause a reset
64:            
65:            // CONFIG3
66:            #pragma config WDTCPS = WDTCPS_31    // WDT Period Select bits->Divider ratio 1:65536; software control of WDTPS
67:            #pragma config WDTE = OFF    // WDT operating mode->WDT Disabled, SWDTEN is ignored
68:            #pragma config WDTCWS = WDTCWS_7    // WDT Window Select bits->window always open (100%); software control; keyed access not required
69:            #pragma config WDTCCS = SC    // WDT input clock selector->Software Control
70:            
71:            // CONFIG4
72:            #pragma config WRT = OFF    // UserNVM self-write protection bits->Write protection off
73:            #pragma config SCANE = available    // Scanner Enable bit->Scanner module is available for use
74:            #pragma config LVP = ON    // Low Voltage Programming Enable bit->Low Voltage programming enabled. MCLR/Vpp pin function is MCLR.
75:            
76:            // CONFIG5
77:            #pragma config CP = OFF    // UserNVM Program memory code protection bit->UserNVM code protection disabled
78:            #pragma config CPD = OFF    // DataNVM code protection bit->DataNVM code protection disabled
79:            
80:            #include "mcc.h"
81:            
82:            void SYSTEM_Initialize(void)
83:            {
84:                
85:                PIN_MANAGER_Initialize();
0994  21AA     CALL 0x1AA
0995  3188     MOVLP 0x8
86:                OSCILLATOR_Initialize();
0996  21A1     CALL 0x1A1
0997  3188     MOVLP 0x8
87:                SPI1_Initialize();
0998  2204     CALL 0x204
0999  3188     MOVLP 0x8
88:                TMR2_Initialize();
099A  220B     CALL 0x20B
099B  3188     MOVLP 0x8
89:                PWM7_Initialize();
099C  21F7     CALL 0x1F7
90:                CWG1_Initialize();
099D  3185     MOVLP 0x5
099E  258C     CALL 0x58C
91:                EUSART_Initialize();
099F  3185     MOVLP 0x5
09A0  2DB2     GOTO 0x5B2
92:            }
93:            
94:            void OSCILLATOR_Initialize(void)
95:            {
96:                // NOSC HFINTOSC; NDIV 1; 
97:                OSCCON1 = 0x60;
09A1  3060     MOVLW 0x60
09A2  0031     MOVLB 0x11
09A3  008D     MOVWF OSCCON1
98:                // CSWHOLD may proceed; SOSCPWR Low power; 
99:                OSCCON3 = 0x00;
09A4  018F     CLRF OSCCON3
100:               // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
101:               OSCEN = 0x00;
09A5  0191     CLRF OSCEN
102:               // HFFRQ 32_MHz; 
103:               OSCFRQ = 0x06;
09A6  3006     MOVLW 0x6
09A7  0093     MOVWF OSCFRQ
104:               // HFTUN 0; 
105:               OSCTUNE = 0x00;
09A8  0192     CLRF OSCTUNE
106:               // Set the secondary oscillator
107:               
108:           }
09A9  0008     RETURN
109:           
110:           /**
111:            End of File
112:           */
---  /Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/mcc_generated_files/interrupt_manager.c
1:             /**
2:               Generated Interrupt Manager Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.c
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using MPLAB(c) Code Configurator
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  MPLAB(c) Code Configurator - 3.15.0
19:                    Device            :  PIC16F18855
20:                    Driver Version    :  1.02
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 1.35
23:                    MPLAB             :  MPLAB X 3.20
24:            */
25:            
26:            /*
27:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
28:                software and any derivatives exclusively with Microchip products.
29:            
30:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
31:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
32:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
33:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
34:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
35:            
36:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
37:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
38:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
39:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
40:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
41:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
42:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
43:            
44:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
45:                TERMS.
46:             */
47:            
48:            #include "interrupt_manager.h"
49:            #include "mcc.h"
50:            
51:            void interrupt INTERRUPT_InterruptManager (void)
0004  147E     BSF 0x8FE, 0x0
0005  3180     MOVLP 0x0
52:            {
53:               // interrupt handler
54:            //    if(PIE4bits.TMR2IE == 1 && PIR4bits.TMR2IF == 1)
55:            //    {
56:                    TMR2_ISR();
0006  3185     MOVLP 0x5
0007  2599     CALL 0x599
57:            //    }
58:            //    else
59:            //    {
60:            //        Unhandled Interrupt
61:            //    }
62:            }
0008  107E     BCF 0x8FE, 0x0
0009  0009     RETFIE
63:            /**
64:             End of File
65:            */
---  /Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/mcc_generated_files/eusart.c
1:             /**
2:               EUSART Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 eusart.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the EUSART driver using MPLAB(c) Code Configurator
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for EUSART.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 3.15.0
17:                    Device            :  PIC16F18855
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.20
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:            */
45:            
46:            /**
47:              Section: Included Files
48:            */
49:            #include "eusart.h"
50:            
51:            /**
52:              Section: EUSART APIs
53:            */
54:            
55:            void EUSART_Initialize(void)
56:            {
57:                // Set the EUSART module to the options selected in the user interface.
58:            
59:                // ABDOVF no_overflow; SCKP Non-Inverted; BRG16 16bit_generator; WUE disabled; ABDEN disabled; 
60:                BAUD1CON = 0x08;
05B2  3008     MOVLW 0x8
05B3  0022     MOVLB 0x2
05B4  009F     MOVWF BAUD1CON
61:            
62:                // SPEN enabled; RX9 8-bit; CREN enabled; ADDEN disabled; SREN disabled; 
63:                RC1STA = 0x90;
05B5  3090     MOVLW 0x90
05B6  009D     MOVWF RC1STA
64:            
65:                // TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN enabled; SYNC asynchronous; BRGH hi_speed; CSRC slave; 
66:                TX1STA = 0x24;
05B7  3024     MOVLW 0x24
05B8  009E     MOVWF TX1STA
67:            
68:                // Baud Rate = 9600; SP1BRGL 64; 
69:                SP1BRGL = 0x40;
05B9  3040     MOVLW 0x40
05BA  009B     MOVWF SP1BRG
70:            
71:                // Baud Rate = 9600; SP1BRGH 3; 
72:                SP1BRGH = 0x03;
05BB  3003     MOVLW 0x3
05BC  009C     MOVWF SP1BRGH
73:            
74:            }
05BD  0008     RETURN
75:            
76:            
77:            uint8_t EUSART_Read(void)
78:            {
79:            
80:               RC1STAbits.SREN = 1;
81:                while(!PIR3bits.RCIF)
82:                {
83:                }
84:            
85:                
86:                if(1 == RC1STAbits.OERR)
87:                {
88:                    // EUSART error - restart
89:            
90:                    RC1STAbits.SPEN = 0; 
91:                    RC1STAbits.SPEN = 1; 
92:                }
93:            
94:                return RC1REG;
95:            }
96:            
97:            void EUSART_Write(uint8_t txData)
05BE  00F3     MOVWF 0x173
98:            {
99:                while(0 == PIR3bits.TXIF)
100:               {
101:               }
05BF  002E     MOVLB 0xE
05C0  1E0F     BTFSS PIR3, 0x4
05C1  2DBF     GOTO 0x5BF
102:           
103:               TX1REG = txData;    // Write the data byte to the USART.
05C2  0873     MOVF 0x773, W
05C3  0022     MOVLB 0x2
05C4  009A     MOVWF TX1REG
104:           }
05C5  0008     RETURN
105:           
106:           char getch(void)
107:           {
108:               return EUSART_Read();
109:           }
110:           
111:           void putch(char txData)
0982  00F4     MOVWF 0x174
112:           {
113:               EUSART_Write(txData);
0983  0874     MOVF 0x174, W
0984  3185     MOVLP 0x5
0985  2DBE     GOTO 0x5BE
114:           }
115:           /**
116:             End of File
117:           */
---  /Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/mcc_generated_files/cwg1.c
1:             /**
2:               CWG1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 cwg1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the CWG1 driver using MPLAB(c) Code Configurator
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for CWG1.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 3.15.0
17:                    Device            :  PIC16F18855
18:                    Driver Version    :  1.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.20
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:            */
45:            
46:            /**
47:              Section: Included Files
48:            */
49:            
50:            #include <xc.h>
51:            #include "cwg1.h"
52:            
53:            /**
54:              Section: CWG1 APIs
55:            */
56:            
57:            void CWG1_Initialize(void)
58:            {
59:                // Set the CWG1 to the options selected in MPLAB(c) Code Configurator
60:            
61:                // Writing to CWGxCON0, CWGxCON1, CWGxCON2, CWGxDBR & CWGxDBF registers
62:            	// CWG1POLA non inverted; CWG1POLC non inverted; CWG1POLB non inverted; CWG1POLD non inverted; 
63:            	CWG1CON1 = 0x00;
058C  002C     MOVLB 0xC
058D  0191     CLRF CWG1CON1
64:            	// CWG1DBR 0; 
65:            	CWG1DBR = 0x00;
058E  018E     CLRF CWG1DBR
66:            	// CWG1DBF 0; 
67:            	CWG1DBF = 0x00;
058F  018F     CLRF CWG1DBF
68:            	// CWG1SHUTDOWN No Auto-shutdown; CWG1REN disabled; CWG1LSBD inactive; CWG1LSAC inactive; 
69:            	CWG1AS0 = 0x00;
0590  0192     CLRF CWG1AS0
70:            	// AS1E disabled; AS0E disabled; AS3E disabled; AS2E disabled; AS5E disabled; AS4E disabled; AS6E disabled; 
71:            	CWG1AS1 = 0x00;
0591  0193     CLRF CWG1AS1
72:            	// CWG1STRD disabled; CWG1STRB disabled; CWG1STRC disabled; CWG1STRA disabled; CWG1OVRD low; CWG1OVRA low; CWG1OVRB low; CWG1OVRC low; 
73:            	CWG1STR = 0x00;
0592  0194     CLRF CWG1STR
74:            	// CWG1CS FOSC; 
75:            	CWG1CLKCON = 0x00;
0593  018C     CLRF CWG1CLKCON
76:            	// IS PWM7_OUT; 
77:            	CWG1ISM = 0x07;
0594  3007     MOVLW 0x7
0595  008D     MOVWF CWG1ISM
78:                
79:                // CWG1LD Buffer_not_loaded; CWG1EN enabled; CWG1MODE Half bridge mode; 
80:                CWG1CON0 = 0x84;
0596  3084     MOVLW 0x84
0597  0090     MOVWF CWG1CON0
81:            }
0598  0008     RETURN
82:            
83:            void CWG1_LoadRiseDeadbandCount(uint8_t dutyValue)
84:            {
85:                // Writing 6 bits of rising dead band count into CWGxDBR register
86:                CWG1DBR = dutyValue;
87:            }
88:            
89:            void CWG1_LoadFallDeadbandCount(uint8_t dutyValue)
90:            {
91:                // Writing 6 bits of rising dead band count into CWGxDBF register
92:                CWG1DBF = dutyValue;
93:            }
94:            
95:            void CWG1_LoadBufferEnable(void)
96:            {
97:            	//It sets the CWG1CON0<LD> bit
98:                CWG1CON0bits.CWG1LD = 1;
99:            }
100:           
101:           bool CWG1_IsModuleEnabled()
102:           {
103:           	//returns whether the module is enabled or not
104:               return (CWG1CON0bits.CWG1EN);
105:           }
106:           
107:           void CWG1_AutoShutdownEventSet()
108:           {
109:               // Setting the SHUTDOWN bit of CWGxAS0 register
110:               CWG1AS0bits.CWG1SHUTDOWN = 1;
111:           }
112:           
113:           void CWG1_AutoShutdownEventClear()
114:           {
115:               // Clearing the SHUTDOWN bit of CWGxAS0 register
116:               CWG1AS0bits.CWG1SHUTDOWN = 0;
117:           }
118:           
119:           /**
120:            End of File
121:           */
---  /Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/main.c  -------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using MPLAB(c) Code Configurator
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 3.15.0
17:                    Device            :  PIC16F18855
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.20
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:             */
45:            
46:            #include "mcc_generated_files/mcc.h"
47:            #include "Wave.h"
48:            #include "fileio.h"
49:            
50:            void main(void)
51:            {
52:                unsigned long lc;   // file length
53:                MFILE* fp;          // file pointer
54:                unsigned int entry; // current piece
55:            
56:                SYSTEM_Initialize();
0801  2194     CALL 0x194
0802  3188     MOVLP 0x8
57:            
58:                LED0_LAT = 0;
0803  0020     MOVLB 0x0
0804  1016     BCF LATA, 0x0
59:                LED1_LAT = 0;
0805  1096     BCF LATA, 0x1
60:                
61:                puts("Xpress WAV Player");
0806  3047     MOVLW 0x47
0807  00A0     MOVWF __pcstackBANK0
0808  3090     MOVLW 0x90
0809  00A1     MOVWF quotient
080A  2077     CALL 0x77
080B  3188     MOVLP 0x8
62:                
63:                while  (1)  // main loop
64:                {
65:                    if (mount() != 0)
080C  2855     GOTO 0x55
0855  3181     MOVLP 0x1
0856  2106     CALL 0x106
0857  3188     MOVLP 0x8
0858  3A00     XORLW 0x0
0859  1D03     BTFSS STATUS, 0x2
085A  280D     GOTO 0xD
66:                    {
67:                        LED0_LAT = 1;       // turn on LED0 if mount successful
080D  0020     MOVLB 0x0
080E  1416     BSF LATA, 0x0
68:                        puts("SD card found");
080F  306A     MOVLW 0x6A
0810  00A0     MOVWF __pcstackBANK0
0811  3090     MOVLW 0x90
0812  00A1     MOVWF quotient
0813  2077     CALL 0x77
0814  3188     MOVLP 0x8
69:                        entry = 0;
0815  0021     MOVLB 0x1
0816  01D5     CLRF entry
0817  01D6     CLRF 0xD6
70:            
71:                        // look for a  WAV file
72:                        while ((fp = ffindM("WAV", &entry)) != NULL)
0854  2818     GOTO 0x18
73:                        {
74:                            puts("WAV file(s) found, ready to play");
0826  3008     MOVLW 0x8
0827  0020     MOVLB 0x0
0828  00A0     MOVWF __pcstackBANK0
0829  3090     MOVLW 0x90
082A  00A1     MOVWF quotient
082B  2077     CALL 0x77
082C  3188     MOVLP 0x8
75:                            LED0_LAT = 0;       // turn off lED0 to save power
082D  0020     MOVLB 0x0
082E  1016     BCF LATA, 0x0
76:                            LED1_LAT = 1;       // turn on LED1 if mount successful
082F  1496     BSF LATA, 0x1
77:                            // wait for button press
78:                            while (SW1_GetValue());
0830  1A8C     BTFSC PORTA, 0x5
0831  2830     GOTO 0x30
79:                            // wait for button release
80:                            while (!SW1_GetValue());
0832  1E8C     BTFSS PORTA, 0x5
0833  2832     GOTO 0x32
81:                            LED1_LAT = 0;       // turn off LED1 to save power
0834  1096     BCF LATA, 0x1
82:            
83:                            lc = InitWAV(fp);
0835  0021     MOVLB 0x1
0836  0854     MOVF fp, W
0837  24E6     CALL 0x4E6
0838  3188     MOVLP 0x8
0839  0823     MOVF fp, W
083A  00D3     MOVWF 0xD3
083B  0822     MOVF 0xA2, W
083C  00D2     MOVWF 0xD2
083D  0821     MOVF r, W
083E  00D1     MOVWF 0xD1
083F  0820     MOVF __pcstackBANK1, W
0840  00D0     MOVWF lc
84:                            Play(fp, lc);
0841  0853     MOVF 0xD3, W
0842  0020     MOVLB 0x0
0843  00EB     MOVWF r
0844  0021     MOVLB 0x1
0845  0852     MOVF 0xD2, W
0846  0020     MOVLB 0x0
0847  00EA     MOVWF fp
0848  0021     MOVLB 0x1
0849  0851     MOVF 0xD1, W
084A  0020     MOVLB 0x0
084B  00E9     MOVWF 0x69
084C  0021     MOVLB 0x1
084D  0850     MOVF lc, W
084E  0020     MOVLB 0x0
084F  00E8     MOVWF lc
0850  0021     MOVLB 0x1
0851  0854     MOVF fp, W
0852  23D9     CALL 0x3D9
0853  3188     MOVLP 0x8
85:                        } // while 
0818  3078     MOVLW 0x78
0819  0020     MOVLB 0x0
081A  00C8     MOVWF ext
081B  3090     MOVLW 0x90
081C  00C9     MOVWF buffer
081D  30D5     MOVLW 0xD5
081E  00CA     MOVWF entry
081F  221E     CALL 0x21E
0820  3188     MOVLP 0x8
0821  0021     MOVLB 0x1
0822  00D4     MOVWF fp
0823  0854     MOVF fp, W
0824  1903     BTFSC 0x83, 0x2
0825  2855     GOTO 0x55
86:                    }
87:                    else {
88:                        LED0_LAT = 0;       // mounting error
085B  0020     MOVLB 0x0
085C  1016     BCF LATA, 0x0
89:                        printf("mount failed with code: %02x\n", FError);
085D  3029     MOVLW 0x29
085E  00A3     MOVWF f
085F  3090     MOVLW 0x90
0860  00A4     MOVWF n
0861  0021     MOVLB 0x1
0862  085C     MOVF FError, W
0863  0020     MOVLB 0x0
0864  00A5     MOVWF 0x25
0865  01A6     CLRF a
0866  2080     CALL 0x80
0867  3188     MOVLP 0x8
90:                        __delay_ms(250);
0868  300B     MOVLW 0xB
0869  0021     MOVLB 0x1
086A  00CF     MOVWF 0xCF
086B  3026     MOVLW 0x26
086C  00CE     MOVWF 0xCE
086D  3066     MOVLW 0x66
086E  00CD     MOVWF 0xCD
086F  0BCD     DECFSZ 0xCD, F
0870  286F     GOTO 0x6F
0871  0BCE     DECFSZ 0xCE, F
0872  286F     GOTO 0x6F
0873  0BCF     DECFSZ 0xCF, F
0874  286F     GOTO 0x6F
0875  3200     BRA 0x876
0876  2855     GOTO 0x55
91:                    }
92:                }
93:            }
---  /Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/fileio.c  -----------
1:             /*
2:             ** fileio.c
3:             ** 
4:             ** FAT16 FILE I/O support
5:             */
6:             #define DBGNOT
7:             #include <stdlib.h>     // malloc...
8:             #include <ctype.h>      // toupper...
9:             #include <string.h>     // memcpy...
10:            #include "fileio.h"     // file I/O routines
11:            
12:            //-------------------------------------------------------------
13:            // Master Boot Record key fields offsets
14:            #define FO_MBR          0L   // master boot record sector LBA
15:            #define FO_FIRST_P    0x1BE  // offset of first partition table
16:            #define FO_FIRST_TYPE 0x1C2  // offset of first partition type
17:            #define FO_FIRST_SECT 0x1C6  // first sector of first partition
18:            #define FO_FIRST_SIZE 0x1CA  // number of sectors in partition
19:            #define FO_SIGN       0x1FE  // MBR signature location (55,AA)
20:            
21:            #define FAT_EOF       0xffff // last cluster in a file
22:            #define FAT_MCLST     0xfff8 // max cluster value in a fat 
23:            
24:            // Partition Boot Record key fields offsets
25:            #define BR_SXC      0xd      // (byte) sector per cluster 
26:            #define BR_RES      0xe      // (word) res sectors boot record
27:            #define BR_FAT_SIZE 0x16     // (word) FAT size sectors 
28:            #define BR_FAT_CPY  0x10     // (byte) number of FAT copies
29:            #define BR_MAX_ROOT 0x11     // (odd word) max entries root dir
30:            
31:            // directory entry management
32:            #define DIR_ESIZE   32      // size of a directory entry(bytes)
33:            #define DIR_NAME    0       // offset file name
34:            #define DIR_EXT     8       // offset file extension
35:            #define DIR_ATTRIB  11      // offset attribute( 00ARSHDV)
36:            #define DIR_CTIME   14      // creation time
37:            #define DIR_CDATE   16      // creation date
38:            #define DIR_ADATE   18      // last access date
39:            #define DIR_TIME    22      // offset last use time  (word)
40:            #define DIR_DATE    24      // offset last use date  (word)
41:            #define DIR_CLST    26      // offset first cluster FAT (word)
42:            #define DIR_SIZE    28      // offset of file size (dword)
43:            #define DIR_DEL     0xE5    // marker deleted entry
44:            #define DIR_EMPTY   0       // marker last entry in directory
45:            
46:            // global definitions
47:            char FError;                // error mail box   
48:            MEDIA *D;                   // mounting info for storage device
49:            
50:            #define F_MAX 3             // max number of files open
51:            
52:            MFILE F[1];
53:            MEDIA disk;
54:            
55:            unsigned char B[F_MAX][256];
56:            
57:            //-------------------------------------------------------------
58:            // mount    initializes a MEDIA structure for file IO access
59:            //
60:            // will mount only the first partition on the disk/card
61:            MEDIA * mount( void)
62:            { 
63:                LBA  psize;      // number of sectors in partition
64:                LBA  firsts;     // first sector inside the first partition
65:                int i;
66:                unsigned char *buffer;
67:                
68:            #ifdef DBG
69:                Fcount = Bcount = 0;
70:            #endif
71:            
72:                // 0. init the I/Os
73:                InitSD();
0106  240C     CALL 0x40C
0107  3180     MOVLP 0x0
74:            
75:                // 1. check if the card is in the slot 
76:                if (!DetectSD()) 
0108  2408     CALL 0x408
0109  3180     MOVLP 0x0
010A  0873     MOVF 0xF3, W
010B  0474     IORWF 0xF4, W
010C  1D03     BTFSS 0x83, 0x2
010D  2912     GOTO 0x112
77:                {
78:                    FError = FE_NOT_PRESENT;
010E  3002     MOVLW 0x2
010F  0021     MOVLB 0x1
0110  00DC     MOVWF FError
79:                    return NULL;    
0111  3400     RETLW 0x0
80:                }
81:            
82:                // 2. initialize the card    
83:                if ( InitMedia())
0112  235D     CALL 0x35D
0113  3180     MOVLP 0x0
0114  0826     MOVF 0xA6, W
0115  0427     IORWF 0xA7, W
0116  1903     BTFSC 0x83, 0x2
0117  291C     GOTO 0x11C
84:                { 
85:                    FError = FE_CANNOT_INIT;
0118  300F     MOVLW 0xF
0119  0021     MOVLB 0x1
011A  00DC     MOVWF FError
86:                    return NULL;
011B  3400     RETLW 0x0
87:                }
88:               
89:                // 3. allocate space for a MEDIA structure 
90:                D = &disk;
011C  3049     MOVLW 0x49
011D  0021     MOVLB 0x1
011E  00DB     MOVWF D
91:            
92:                // 4. allocate space for a temp sector buffer
93:                D->cb = 0;           // take the first two half buffers [0][1]
011F  0086     MOVWF 0x86
0120  3001     MOVLW 0x1
0121  0087     MOVWF 0x87
0123  0181     CLRF 0x81
94:                buffer = &B[ 0];
0122  3020     MOVLW 0x20
0124  0020     MOVLB 0x0
0125  00CA     MOVWF entry
0126  30F0     MOVLW 0xF0
0127  00C9     MOVWF buffer
95:            
96:                // 5.  get the Master Boot Record 
97:                if ( !ReadSECTOR( FO_MBR, buffer))
0128  01A6     CLRF a
0129  01A7     CLRF 0x27
012A  01A8     CLRF 0x28
012B  01A9     CLRF r
012C  084A     MOVF entry, W
012D  00AB     MOVWF i
012E  0849     MOVF buffer, W
012F  00AA     MOVWF p
0130  22D7     CALL 0x2D7
0131  3180     MOVLP 0x0
0132  0826     MOVF a, W
0133  0427     IORWF 0x27, W
0134  1D03     BTFSS STATUS, 0x2
0135  293A     GOTO 0x13A
98:                {
99:                    FError = FE_CANNOT_READ_MBR;
0136  3010     MOVLW 0x10
0137  0021     MOVLB 0x1
0138  00DC     MOVWF FError
100:           //        free( D); free( buffer);
101:                   return NULL;
0139  3400     RETLW 0x0
102:               }
103:                   
104:               // 6. check if the MBR sector is valid 
105:               //      verify the signature word
106:               if (( buffer[ FO_SIGN] != 0x55) ||
107:                   ( buffer[ FO_SIGN +1] != 0xAA))
013A  0849     MOVF 0xC9, W
013B  3EFE     ADDLW 0xFE
013C  0086     MOVWF 0x86
013D  3001     MOVLW 0x1
013E  3D4A     ADDWFC 0xCA, W
013F  0087     MOVWF 0x87
0140  3055     MOVLW 0x55
0141  0601     XORWF 0x81, W
0142  1D03     BTFSS 0x83, 0x2
0143  294E     GOTO 0x14E
0144  0849     MOVF 0xC9, W
0145  3EFF     ADDLW 0xFF
0146  0086     MOVWF 0x86
0147  3001     MOVLW 0x1
0148  3D4A     ADDWFC 0xCA, W
0149  0087     MOVWF 0x87
014A  30AA     MOVLW 0xAA
014B  0601     XORWF 0x81, W
014C  1903     BTFSC 0x83, 0x2
014D  2952     GOTO 0x152
108:               {
109:                   FError = FE_INVALID_MBR;
014E  3004     MOVLW 0x4
014F  0021     MOVLB 0x1
0150  00DC     MOVWF FError
110:           //        free( D); free( buffer);
111:                   return NULL;
0151  3400     RETLW 0x0
112:               }
113:           
114:           //    Valid Master Boot Record Loaded
115:               
116:               // 7. read the number of sectors in partition
117:               psize = ReadL( buffer, FO_FIRST_SIZE);
0152  0849     MOVF 0xC9, W
0153  3ECA     ADDLW 0xCA
0154  0086     MOVWF 0x86
0155  3001     MOVLW 0x1
0156  3D4A     ADDWFC 0xCA, W
0157  0087     MOVWF 0x87
0158  3F40     MOVIW [0]FSR1
0159  00BF     MOVWF 0xBF
015A  3F41     MOVIW [1]FSR1
015B  00C0     MOVWF fp
015C  3F42     MOVIW [2]FSR1
015D  00C1     MOVWF ck
015E  3F43     MOVIW [3]FSR1
015F  00C2     MOVWF 0xC2
118:               
119:               // 8. check if the partition type is acceptable
120:               i = buffer[ FO_FIRST_TYPE];
0160  0849     MOVF 0xC9, W
0161  3EC2     ADDLW 0xC2
0162  0086     MOVWF 0x86
0163  3001     MOVLW 0x1
0164  3D4A     ADDWFC 0xCA, W
0165  0087     MOVWF 0x87
0166  0801     MOVF 0x81, W
0167  00C3     MOVWF 0xC3
0168  01C4     CLRF 0xC4
121:               switch ( i)
0169  296F     GOTO 0x16F
016F  0844     MOVF 0xC4, W
0170  3A00     XORLW 0x0
0171  1903     BTFSC 0x83, 0x2
0172  2974     GOTO 0x174
0173  296B     GOTO 0x16B
0174  0843     MOVF 0xC3, W
0175  3A04     XORLW 0x4
0176  1903     BTFSC 0x83, 0x2
0177  296A     GOTO 0x16A
0178  3A02     XORLW 0x2
0179  1903     BTFSC 0x83, 0x2
017A  297F     GOTO 0x17F
017B  3A08     XORLW 0x8
017C  1903     BTFSC 0x83, 0x2
017D  297F     GOTO 0x17F
017E  296B     GOTO 0x16B
122:               {
123:                   case 0x04:
124:                   case 0x06:
125:                   case 0x0E:
126:                       // valid FAT16 options
127:                       break;
016A  297F     GOTO 0x17F
128:                   default:
129:                       FError = FE_PARTITION_TYPE;
016B  3003     MOVLW 0x3
016C  0021     MOVLB 0x1
016D  00DC     MOVWF FError
130:           //            free( D); free( buffer);
131:                       return NULL;
016E  3400     RETLW 0x0
132:               } // switch
133:                   
134:               // 9. get the first partition first sector -> Boot Record
135:               //  get the 32 bit offset to the first partition 
136:               firsts = ReadL( buffer, FO_FIRST_SECT); 
017F  0849     MOVF 0xC9, W
0180  3EC6     ADDLW 0xC6
0181  0086     MOVWF 0x86
0182  3001     MOVLW 0x1
0183  3D4A     ADDWFC 0xCA, W
0184  0087     MOVWF 0x87
0185  3F40     MOVIW [0]FSR1
0186  00C5     MOVWF 0xC5
0187  3F41     MOVIW [1]FSR1
0188  00C6     MOVWF 0xC6
0189  3F42     MOVIW [2]FSR1
018A  00C7     MOVWF 0xC7
018B  3F43     MOVIW [3]FSR1
018C  00C8     MOVWF 0xC8
137:               // assuming FO_MBR == 0 
138:               
139:               // 10. get the sector loaded (boot record)
140:               if ( !ReadSECTOR( firsts, buffer))
018D  00A9     MOVWF skip
018E  0847     MOVF 0xC7, W
018F  00A8     MOVWF 0xA8
0190  0846     MOVF 0xC6, W
0191  00A7     MOVWF 0xA7
0192  0845     MOVF 0xC5, W
0193  00A6     MOVWF 0xA6
0194  084A     MOVF 0xCA, W
0195  00AB     MOVWF stereo
0196  0849     MOVF 0xC9, W
0197  00AA     MOVWF size
0198  22D7     CALL 0x2D7
0199  3180     MOVLP 0x0
019A  0826     MOVF 0xA6, W
019B  0427     IORWF 0xA7, W
019C  1903     BTFSC 0x83, 0x2
141:               {
142:           //        free( D); free( buffer);
143:                   return NULL;
019D  3400     RETLW 0x0
144:               }
145:           
146:               // 11. check if the boot record is valid 
147:               //      verify the signature word
148:               if (( buffer[ FO_SIGN] != 0x55) ||
149:                   ( buffer[ FO_SIGN +1] != 0xAA))
019E  0849     MOVF 0xC9, W
019F  3EFE     ADDLW 0xFE
01A0  0086     MOVWF 0x86
01A1  3001     MOVLW 0x1
01A2  3D4A     ADDWFC 0xCA, W
01A3  0087     MOVWF 0x87
01A4  3055     MOVLW 0x55
01A5  0601     XORWF 0x81, W
01A6  1D03     BTFSS 0x83, 0x2
01A7  29B2     GOTO 0x1B2
01A8  0849     MOVF 0xC9, W
01A9  3EFF     ADDLW 0xFF
01AA  0086     MOVWF 0x86
01AB  3001     MOVLW 0x1
01AC  3D4A     ADDWFC 0xCA, W
01AD  0087     MOVWF 0x87
01AE  30AA     MOVLW 0xAA
01AF  0601     XORWF 0x81, W
01B0  1903     BTFSC 0x83, 0x2
01B1  29B6     GOTO 0x1B6
150:               {
151:                   FError = FE_INVALID_BR;
01B2  3005     MOVLW 0x5
01B3  0021     MOVLB 0x1
01B4  00DC     MOVWF FError
152:           //        free( D); free( buffer);
153:                   return NULL;
01B5  3400     RETLW 0x0
154:               }
155:           
156:           // Valid Partition Boot Record Loaded       
157:               // get the full partition/drive layout
158:           
159:               // 12. determine the size of a cluster
160:               D->sxc = buffer[ BR_SXC];
01B6  0021     MOVLB 0x1
01B7  085B     MOVF D, W
01B8  3E14     ADDLW 0x14
01B9  0086     MOVWF 0x86
01BA  3001     MOVLW 0x1
01BB  0087     MOVWF 0x87
01BC  0020     MOVLB 0x0
01BD  0849     MOVF buffer, W
01BE  0084     MOVWF FSR0
01BF  084A     MOVF entry, W
01C0  0085     MOVWF FSR0H
01C1  310D     ADDFSR 0, 13
01C2  0800     MOVF INDF0, W
01C3  0081     MOVWF INDF1
161:               // this will also act as flag that the disk is mounted
162:               
163:               // 13. determine fat, root and data LBAs
164:               // FAT = first sector in partition 
165:               // (boot record) + reserved records
166:               D->fat = firsts + ReadW( buffer, BR_RES);
01C4  0845     MOVF firsts, W
01C5  00B5     MOVWF e
01C6  0846     MOVF l, W
01C7  00B6     MOVWF 0x36
01C8  0847     MOVF fp, W
01C9  00B7     MOVWF 0x37
01CA  0848     MOVF ext, W
01CB  00B8     MOVWF l
01CC  084A     MOVF entry, W
01CD  00BA     MOVWF 0x3A
01CE  0849     MOVF buffer, W
01CF  00B9     MOVWF 0x39
01D0  3E0E     ADDLW 0xE
01D1  0084     MOVWF FSR0
01D2  083A     MOVF 0x3A, W
01D3  1803     BTFSC STATUS, 0x0
01D4  0A3A     INCF 0x3A, W
01D5  0085     MOVWF FSR0H
01D6  3F00     MOVIW [0]FSR0
01D7  00BB     MOVWF 0x3B
01D8  3F01     MOVIW [1]FSR0
01D9  00BC     MOVWF fp
01DA  01BD     CLRF 0x3D
01DB  01BE     CLRF 0x3E
01DC  083B     MOVF 0x3B, W
01DD  07B5     ADDWF e, F
01DE  083C     MOVF fp, W
01DF  3DB6     ADDWFC 0x36, F
01E0  083D     MOVF 0x3D, W
01E1  3DB7     ADDWFC 0x37, F
01E2  083E     MOVF 0x3E, W
01E3  3DB8     ADDWFC l, F
01E4  0021     MOVLB 0x1
01E5  0A5B     INCF D, W
01E6  0086     MOVWF 0x86
01E7  3001     MOVLW 0x1
01E8  0087     MOVWF 0x87
01E9  0020     MOVLB 0x0
01EA  0835     MOVF e, W
01EB  3FC0     MOVWI [0]FSR1
01EC  0836     MOVF 0x36, W
01ED  3FC1     MOVWI [1]FSR1
01EE  0837     MOVF 0x37, W
01EF  3FC2     MOVWI [2]FSR1
01F0  0838     MOVF l, W
01F1  3FC3     MOVWI [3]FSR1
167:               D->fatsize = ReadW( buffer, BR_FAT_SIZE);
01F2  0849     MOVF buffer, W
01F3  0086     MOVWF FSR1
01F4  084A     MOVF entry, W
01F5  0087     MOVWF FSR1H
01F6  3156     ADDFSR 1, 22
01F7  0021     MOVLB 0x1
01F8  085B     MOVF D, W
01F9  3E11     ADDLW 0x11
01FA  0084     MOVWF 0x84
01FB  3001     MOVLW 0x1
01FC  0085     MOVWF 0x85
01FD  3F40     MOVIW [0]FSR1
01FE  3F80     MOVWI [0]FSR0
01FF  3F41     MOVIW [1]FSR1
0200  3F81     MOVWI [1]FSR0
168:               D->fatcopy = buffer[ BR_FAT_CPY];
0201  085B     MOVF D, W
0202  3E13     ADDLW 0x13
0203  0086     MOVWF 0x86
0204  3001     MOVLW 0x1
0205  0087     MOVWF 0x87
0206  0020     MOVLB 0x0
0207  0849     MOVF buffer, W
0208  0084     MOVWF FSR0
0209  084A     MOVF entry, W
020A  0085     MOVWF FSR0H
020B  3110     ADDFSR 0, 16
020C  0800     MOVF INDF0, W
020D  0081     MOVWF INDF1
169:               
170:               // 14. ROOT = FAT + (sectors per FAT *  copies of FAT)
171:               D->root = D->fat + ( D->fatsize * D->fatcopy);
020E  0021     MOVLB 0x1
020F  0A5B     INCF D, W
0210  0086     MOVWF 0x86
0211  3001     MOVLW 0x1
0212  0087     MOVWF 0x87
0213  3F40     MOVIW [0]FSR1
0214  0020     MOVLB 0x0
0215  00B5     MOVWF e
0216  3F41     MOVIW [1]FSR1
0217  00B6     MOVWF 0x36
0218  3F42     MOVIW [2]FSR1
0219  00B7     MOVWF 0x37
021A  3F43     MOVIW [3]FSR1
021B  00B8     MOVWF l
021C  0021     MOVLB 0x1
021D  085B     MOVF D, W
021E  3E13     ADDLW 0x13
021F  0086     MOVWF 0x86
0220  0801     MOVF 0x81, W
0221  00F3     MOVWF 0xF3
0222  01F4     CLRF 0xF4
0223  085B     MOVF D, W
0224  3E11     ADDLW 0x11
0225  0086     MOVWF 0x86
0226  3F40     MOVIW [0]FSR1
0227  00F5     MOVWF 0xF5
0228  3F41     MOVIW [1]FSR1
0229  00F6     MOVWF 0xF6
022A  2410     CALL 0x410
022B  3180     MOVLP 0x0
022C  0873     MOVF 0xF3, W
022D  00B9     MOVWF 0xB9
022E  0874     MOVF 0xF4, W
022F  00BA     MOVWF 0xBA
0230  01BB     CLRF 0xBB
0231  01BC     CLRF 0xBC
0232  0839     MOVF 0xB9, W
0233  07B5     ADDWF 0xB5, F
0234  083A     MOVF 0xBA, W
0235  3DB6     ADDWFC 0xB6, F
0236  083B     MOVF 0xBB, W
0237  3DB7     ADDWFC 0xB7, F
0238  083C     MOVF 0xBC, W
0239  3DB8     ADDWFC 0xB8, F
023A  0021     MOVLB 0x1
023B  085B     MOVF D, W
023C  3E05     ADDLW 0x5
023D  0086     MOVWF 0x86
023E  3001     MOVLW 0x1
023F  0087     MOVWF 0x87
0240  0020     MOVLB 0x0
0241  0835     MOVF e, W
0242  3FC0     MOVWI [0]FSR1
0243  0836     MOVF 0x36, W
0244  3FC1     MOVWI [1]FSR1
0245  0837     MOVF 0x37, W
0246  3FC2     MOVWI [2]FSR1
0247  0838     MOVF l, W
0248  3FC3     MOVWI [3]FSR1
172:               
173:               // 15. MAX ROOT is the maximum number of entries 
174:               //      in the root directory
175:               D->maxroot = ReadOddW( buffer, BR_MAX_ROOT) ;
0249  0849     MOVF buffer, W
024A  0084     MOVWF FSR0
024B  084A     MOVF entry, W
024C  0085     MOVWF FSR0H
024D  3111     ADDFSR 0, 17
024E  0800     MOVF INDF0, W
024F  00B5     MOVWF e
0250  0849     MOVF buffer, W
0251  0084     MOVWF FSR0
0252  084A     MOVF entry, W
0253  0085     MOVWF FSR0H
0254  3112     ADDFSR 0, 18
0255  0021     MOVLB 0x1
0256  085B     MOVF D, W
0257  3E0D     ADDLW 0xD
0258  0086     MOVWF 0x86
0259  3001     MOVLW 0x1
025A  0087     MOVWF 0x87
025B  0020     MOVLB 0x0
025C  0835     MOVF e, W
025D  3FC0     MOVWI [0]FSR1
025E  0800     MOVF INDF0, W
025F  3FC1     MOVWI [1]FSR1
176:               
177:               // 16. DATA = ROOT + (MAXIMUM ROOT *32 / 512) 
178:               D->data = D->root + ( D->maxroot >> 4); 
0260  0021     MOVLB 0x1
0261  085B     MOVF D, W
0262  3E05     ADDLW 0x5
0263  0086     MOVWF 0x86
0264  3F40     MOVIW [0]FSR1
0265  0020     MOVLB 0x0
0266  00B5     MOVWF e
0267  3F41     MOVIW [1]FSR1
0268  00B6     MOVWF 0x36
0269  3F42     MOVIW [2]FSR1
026A  00B7     MOVWF 0x37
026B  3F43     MOVIW [3]FSR1
026C  00B8     MOVWF l
026D  0021     MOVLB 0x1
026E  085B     MOVF D, W
026F  3E0D     ADDLW 0xD
0270  0086     MOVWF 0x86
0271  3F40     MOVIW [0]FSR1
0272  0020     MOVLB 0x0
0273  00B9     MOVWF 0x39
0274  3F41     MOVIW [1]FSR1
0275  00BA     MOVWF 0x3A
0276  3004     MOVLW 0x4
0277  36BA     LSRF 0x3A, F
0278  0CB9     RRF 0x39, F
0279  0B89     DECFSZ WREG, F
027A  2A77     GOTO 0x277
027B  0839     MOVF 0x39, W
027C  00BB     MOVWF 0x3B
027D  083A     MOVF 0x3A, W
027E  00BC     MOVWF fp
027F  01BD     CLRF 0x3D
0280  01BE     CLRF 0x3E
0281  083B     MOVF 0x3B, W
0282  07B5     ADDWF e, F
0283  083C     MOVF fp, W
0284  3DB6     ADDWFC 0x36, F
0285  083D     MOVF 0x3D, W
0286  3DB7     ADDWFC 0x37, F
0287  083E     MOVF 0x3E, W
0288  3DB8     ADDWFC l, F
0289  0021     MOVLB 0x1
028A  085B     MOVF D, W
028B  3E09     ADDLW 0x9
028C  0086     MOVWF 0x86
028D  3001     MOVLW 0x1
028E  0087     MOVWF 0x87
028F  0020     MOVLB 0x0
0290  0835     MOVF e, W
0291  3FC0     MOVWI [0]FSR1
0292  0836     MOVF 0x36, W
0293  3FC1     MOVWI [1]FSR1
0294  0837     MOVF 0x37, W
0295  3FC2     MOVWI [2]FSR1
0296  0838     MOVF l, W
0297  3FC3     MOVWI [3]FSR1
179:               // assuming maxroot % 16 == 0!!!
180:           
181:               // 17. max clusters in this partition 
182:               //       = (tot sectors - sys sectors )/sxc
183:               D->maxcls = (psize - (D->data - firsts)) / D->sxc;
0298  0848     MOVF ext, W
0299  00A7     MOVWF 0x27
029A  0847     MOVF fp, W
029B  00A6     MOVWF a
029C  0846     MOVF l, W
029D  00A5     MOVWF 0x25
029E  0845     MOVF firsts, W
029F  00A4     MOVWF n
02A0  0021     MOVLB 0x1
02A1  085B     MOVF D, W
02A2  3E09     ADDLW 0x9
02A3  0086     MOVWF 0x86
02A4  3F40     MOVIW [0]FSR1
02A5  0020     MOVLB 0x0
02A6  00B5     MOVWF e
02A7  3F41     MOVIW [1]FSR1
02A8  00B6     MOVWF 0x36
02A9  3F42     MOVIW [2]FSR1
02AA  00B7     MOVWF 0x37
02AB  3F43     MOVIW [3]FSR1
02AC  00B8     MOVWF l
02AD  0835     MOVF e, W
02AE  02A4     SUBWF n, F
02AF  0836     MOVF 0x36, W
02B0  3BA5     SUBWFB 0x25, F
02B1  0837     MOVF 0x37, W
02B2  3BA6     SUBWFB a, F
02B3  0838     MOVF l, W
02B4  3BA7     SUBWFB 0x27, F
02B5  083F     MOVF psize, W
02B6  07A4     ADDWF n, F
02B7  0840     MOVF 0x40, W
02B8  3DA5     ADDWFC 0x25, F
02B9  0841     MOVF 0x41, W
02BA  3DA6     ADDWFC a, F
02BB  0842     MOVF 0x42, W
02BC  3DA7     ADDWFC 0x27, F
02BD  0021     MOVLB 0x1
02BE  085B     MOVF D, W
02BF  3E14     ADDLW 0x14
02C0  0086     MOVWF 0x86
02C1  0801     MOVF 0x81, W
02C2  0020     MOVLB 0x0
02C3  00A0     MOVWF __pcstackBANK0
02C4  01A1     CLRF quotient
02C5  01A2     CLRF s2
02C6  01A3     CLRF f
02C7  3184     MOVLP 0x4
02C8  2430     CALL 0x430
02C9  0021     MOVLB 0x1
02CA  085B     MOVF D, W
02CB  3E0F     ADDLW 0xF
02CC  0086     MOVWF 0x86
02CD  3001     MOVLW 0x1
02CE  0087     MOVWF 0x87
02CF  0020     MOVLB 0x0
02D0  0820     MOVF __pcstackBANK0, W
02D1  3FC0     MOVWI [0]FSR1
02D2  0821     MOVF quotient, W
02D3  3FC1     MOVWI [1]FSR1
184:               
185:               // 18. free up the temporary buffer
186:           //    free( buffer);
187:               return D;
02D4  0021     MOVLB 0x1
02D5  085B     MOVF D, W
188:           
189:           } // mount
02D6  0008     RETURN
190:           
191:           
192:           //-------------------------------------------------------------
193:           // umount    initializes a MEDIA structure for file IO access
194:           //
195:           void umount( void)
196:           { 
197:           //    free( D);
198:               D = NULL;
199:           } // umount
200:           
201:           
202:           //-------------------------------------------------------------
203:           // 
204:           unsigned ReadDIR( MFILE *fp, unsigned e)
046F  00BC     MOVWF 0xBC
205:           // loads current entry sector in file buffer
206:           // returns      FAIL/TRUE
207:           {        
208:               LBA l;
209:           
210:               // load the root sector containing the DIR entry "e"
211:               l = fp->mda->root + (e >> 4);
0470  0E35     SWAPF 0xB5, W
0471  390F     ANDLW 0xF
0472  00B8     MOVWF 0xB8
0473  0E36     SWAPF 0xB6, W
0474  39F0     ANDLW 0xF0
0475  04B8     IORWF 0xB8, F
0476  0E36     SWAPF 0xB6, W
0477  390F     ANDLW 0xF
0478  00B9     MOVWF 0xB9
0479  01BA     CLRF 0xBA
047A  01BB     CLRF 0xBB
047B  083C     MOVF 0xBC, W
047C  3E02     ADDLW 0x2
047D  0086     MOVWF 0x86
047E  3001     MOVLW 0x1
047F  0087     MOVWF 0x87
0480  0801     MOVF 0x81, W
0481  3E05     ADDLW 0x5
0482  0086     MOVWF 0x86
0483  3F40     MOVIW [0]FSR1
0484  07B8     ADDWF 0xB8, F
0485  3F41     MOVIW [1]FSR1
0486  3DB9     ADDWFC 0xB9, F
0487  3F42     MOVIW [2]FSR1
0488  3DBA     ADDWFC 0xBA, F
0489  3F43     MOVIW [3]FSR1
048A  3DBB     ADDWFC 0xBB, F
212:               fp->fpage = -1;             // invalidate FAT cache
048B  083C     MOVF 0xBC, W
048C  3E25     ADDLW 0x25
048D  0086     MOVWF 0x86
048E  30FF     MOVLW 0xFF
048F  3FC0     MOVWI [0]FSR1
0490  3FC1     MOVWI [1]FSR1
213:               
214:               return ( ReadSECTOR( l, fp->buffer));
0491  083B     MOVF 0xBB, W
0492  00A9     MOVWF skip
0493  083A     MOVF 0xBA, W
0494  00A8     MOVWF 0xA8
0495  0839     MOVF 0xB9, W
0496  00A7     MOVWF 0xA7
0497  0838     MOVF 0xB8, W
0498  00A6     MOVWF 0xA6
0499  083C     MOVF 0xBC, W
049A  0086     MOVWF 0x86
049B  3F40     MOVIW [0]FSR1
049C  00AA     MOVWF size
049D  3F41     MOVIW [1]FSR1
049E  00AB     MOVWF stereo
049F  3182     MOVLP 0x2
04A0  22D7     CALL 0x2D7
04A1  0827     MOVF 0xA7, W
04A2  00B6     MOVWF 0xB6
04A3  0826     MOVF 0xA6, W
04A4  00B5     MOVWF 0xB5
215:           
216:           } // ReadDIR
04A5  0008     RETURN
217:           
218:           
219:           #ifdef _FWRITE_ENABLED
220:           //-------------------------------------------------------------
221:           // 
222:           unsigned WriteDIR( MFILE *fp, unsigned entry)
223:           // write current entry sector 
224:           // returns      FAIL/TRUE
225:           {        
226:               LBA l = fp->mda->root + (entry >> 4);
227:               // write the root sector 
228:               return ( WriteSECTOR( l, fp->buffer)) ;
229:           } // WriteDIR
230:           #endif
231:           
232:           
233:           //-------------------------------------------------------------
234:           // Find a File entry in current directory
235:           //
236:           unsigned FindDIR( MFILE *fp)
237:           // fp       file structure
238:           // return   found/not_found/fail 
239:           {
240:               unsigned eCount;            // current entry counter
241:               unsigned e;                 // current entry offset 
242:               int i, a;             
243:               MEDIA *mda = fp->mda;
244:               
245:               // 1. start from the first entry
246:               eCount = 0;
247:           
248:               // load the first sector of root
249:               if ( !ReadDIR( fp, eCount))
250:                   return FAIL;
251:                       
252:               // 2. loop until you reach the end or find the file
253:               while ( 1)
254:               {
255:               // 2.0 determine the offset in current buffer
256:                   e = (eCount&0xf) * DIR_ESIZE;
257:           
258:               // 2.1 read the first char of the file name 
259:                   a = fp->buffer[ e + DIR_NAME]; 
260:           
261:               // 2.2 terminate if it is empty (end of the list)        
262:                   if ( a == DIR_EMPTY)
263:                   {
264:                       return NOT_FOUND;
265:                   } // empty entry
266:           
267:               // 2.3 skip erased entries if looking for a match
268:                   if ( a != DIR_DEL)
269:                   {
270:                   // 2.3.1 if not VOLume or DIR compare the names
271:                       a = fp->buffer[ e + DIR_ATTRIB];
272:                       if ( !(a & (ATT_DIR | ATT_HIDE)) )
273:                       {   
274:                           // compare file name and extension
275:                           for (i=DIR_NAME; i<DIR_ATTRIB; i++)
276:                           {
277:                              if ( fp->buffer[ e + i] !=  fp->name[i])
278:                                   break;  // difference found
279:                           }
280:           
281:                           if ( i == DIR_ATTRIB)
282:                           {
283:                             // entry found, fill the file structure 
284:                             fp->entry = eCount;         // store index
285:                             fp->time = ReadW( fp->buffer, e+DIR_TIME);
286:                             fp->date = ReadW( fp->buffer, e+DIR_DATE);
287:                             fp->size = ReadL( fp->buffer, e+DIR_SIZE);
288:                             fp->cluster = ReadL( fp->buffer, e+DIR_CLST);
289:                             return FOUND;      
290:                           }
291:                       } // not dir nor vol
292:                   } // not deleted
293:                   
294:               // 2.4 get the next entry
295:                   eCount++;
296:                   if ( (eCount & 0xf) == 0)
297:                   {   // load a new sector from the Dir
298:                       if ( !ReadDIR( fp, eCount))
299:                           return FAIL; 
300:                   }
301:           
302:               //  2.5. exit the loop if reached the end or error
303:                   if ( eCount >= mda->maxroot)
304:                       return NOT_FOUND;       // last entry reached
305:               
306:               }// while
307:           
308:               return NOT_FOUND;
309:               
310:           } // FindDIR
311:           
312:           
313:           //-------------------------------------------------------------
314:           // Read the content of cluster link in FAT
315:           //
316:           // return : 0000 cluster is empty
317:           //          0FF8 last cluster in a chain
318:           //          0xxx next cluster in a chain
319:           //          FFFF FAIL
320:           
321:           unsigned ReadFAT( MFILE *fp, unsigned ccls)
007D  00CC     MOVWF 0xCC
322:           // mda      disk structure
323:           // ccls     current cluster 
324:           // return   next cluster value, 
325:           //          0xffff if failed or last 
326:           {
327:               unsigned p, c;
328:               LBA l;
329:                   
330:               // get page of current cluster in fat
331:               p = ccls >>8;               // 256 clusters per sector  
007E  0836     MOVF 0xB6, W
007F  00CA     MOVWF 0xCA
0080  01CB     CLRF 0xCB
332:           
333:               // check if already cached
334:               if (fp->fpage != p)
0081  084C     MOVF 0xCC, W
0082  3E25     ADDLW 0x25
0083  0086     MOVWF 0x86
0084  3001     MOVLW 0x1
0085  0087     MOVWF 0x87
0086  3F40     MOVIW [0]FSR1
0087  00B7     MOVWF 0xB7
0088  3F41     MOVIW [1]FSR1
0089  00B8     MOVWF 0xB8
008A  064B     XORWF 0xCB, W
008B  1D03     BTFSS 0x83, 0x2
008C  288F     GOTO 0x8F
008D  084A     MOVF 0xCA, W
008E  0637     XORWF 0xB7, W
008F  1903     BTFSC 0x83, 0x2
0090  28CA     GOTO 0xCA
335:               {   
336:                   // load the fat sector containing the cluster
337:                   l = fp->mda->fat + p;   
0091  084A     MOVF 0xCA, W
0092  00C6     MOVWF 0xC6
0093  084B     MOVF 0xCB, W
0094  00C7     MOVWF 0xC7
0095  01C8     CLRF 0xC8
0096  01C9     CLRF 0xC9
0097  084C     MOVF 0xCC, W
0098  3E02     ADDLW 0x2
0099  0086     MOVWF 0x86
009A  3001     MOVLW 0x1
009B  0087     MOVWF 0x87
009C  0A01     INCF 0x81, W
009D  0086     MOVWF 0x86
009E  3F40     MOVIW [0]FSR1
009F  07C6     ADDWF 0xC6, F
00A0  3F41     MOVIW [1]FSR1
00A1  3DC7     ADDWFC 0xC7, F
00A2  3F42     MOVIW [2]FSR1
00A3  3DC8     ADDWFC 0xC8, F
00A4  3F43     MOVIW [3]FSR1
00A5  3DC9     ADDWFC 0xC9, F
338:                   if ( !ReadSECTOR( l, fp->buffer))
00A6  0849     MOVF 0xC9, W
00A7  00A9     MOVWF skip
00A8  0848     MOVF 0xC8, W
00A9  00A8     MOVWF 0xA8
00AA  0847     MOVF 0xC7, W
00AB  00A7     MOVWF 0xA7
00AC  0846     MOVF 0xC6, W
00AD  00A6     MOVWF 0xA6
00AE  084C     MOVF 0xCC, W
00AF  0086     MOVWF 0x86
00B0  3F40     MOVIW [0]FSR1
00B1  00AA     MOVWF size
00B2  3F41     MOVIW [1]FSR1
00B3  00AB     MOVWF stereo
00B4  22D7     CALL 0x2D7
00B5  3180     MOVLP 0x0
00B6  0826     MOVF 0xA6, W
00B7  0427     IORWF 0xA7, W
00B8  1D03     BTFSS 0x83, 0x2
00B9  28BE     GOTO 0xBE
339:                       return FAT_EOF;      // failed
00BA  30FF     MOVLW 0xFF
00BB  00B5     MOVWF 0xB5
00BC  00B6     MOVWF 0xB6
00BD  0008     RETURN
340:                   
341:                   // note the sector contains a valid FAT page cache 
342:                   fp->fpage = ccls>>8;
00BE  0836     MOVF 0xB6, W
00BF  00B7     MOVWF 0xB7
00C0  01B8     CLRF 0xB8
00C1  084C     MOVF 0xCC, W
00C2  3E25     ADDLW 0x25
00C3  0086     MOVWF 0x86
00C4  3001     MOVLW 0x1
00C5  0087     MOVWF 0x87
00C6  0837     MOVF 0xB7, W
00C7  3FC0     MOVWI [0]FSR1
00C8  0838     MOVF 0xB8, W
00C9  3FC1     MOVWI [1]FSR1
343:               }
344:                   
345:               // get the next cluster value
346:               // cluster = 0xabcd
347:               // packed as:     0   |   1    |   2   |  3    |
348:               // word p       0   1 |  2   3 | 4   5 | 6   7 |..
349:               //              cd  ab|  cd  ab| cd  ab| cd  ab| 
350:               c = ReadOddW( fp->buffer, ((ccls & 0xFF)<<1));
00CA  0835     MOVF 0xB5, W
00CB  00B7     MOVWF 0xB7
00CC  01B8     CLRF 0xB8
00CD  35B7     LSLF 0xB7, F
00CE  0DB8     RLF 0xB8, F
00CF  084C     MOVF 0xCC, W
00D0  0086     MOVWF 0x86
00D1  3001     MOVLW 0x1
00D2  0087     MOVWF 0x87
00D3  3F40     MOVIW [0]FSR1
00D4  00B9     MOVWF 0xB9
00D5  3F41     MOVIW [1]FSR1
00D6  00BA     MOVWF 0xBA
00D7  0837     MOVF 0xB7, W
00D8  0739     ADDWF 0xB9, W
00D9  00BB     MOVWF 0xBB
00DA  0838     MOVF 0xB8, W
00DB  3D3A     ADDWFC 0xBA, W
00DC  00BC     MOVWF 0xBC
00DD  083B     MOVF 0xBB, W
00DE  0086     MOVWF 0x86
00DF  083C     MOVF 0xBC, W
00E0  0087     MOVWF 0x87
00E1  3141     ADDFSR 1, 1
00E2  0801     MOVF 0x81, W
00E3  00BD     MOVWF 0xBD
00E4  01BE     CLRF 0xBE
00E5  00BE     MOVWF 0xBE
00E6  01BD     CLRF 0xBD
00E7  0835     MOVF 0xB5, W
00E8  00C0     MOVWF fp
00E9  3000     MOVLW 0x0
00EA  01C1     CLRF ck
00EB  35C0     LSLF fp, F
00EC  0DC1     RLF ck, F
00ED  084C     MOVF 0xCC, W
00EE  0086     MOVWF 0x86
00EF  3001     MOVLW 0x1
00F0  0087     MOVWF 0x87
00F1  3F40     MOVIW [0]FSR1
00F2  00C2     MOVWF 0xC2
00F3  3F41     MOVIW [1]FSR1
00F4  00C3     MOVWF 0xC3
00F5  0840     MOVF fp, W
00F6  0742     ADDWF 0xC2, W
00F7  0086     MOVWF 0x86
00F8  0841     MOVF ck, W
00F9  3D43     ADDWFC 0xC3, W
00FA  0087     MOVWF 0x87
00FB  0801     MOVF 0x81, W
00FC  073D     ADDWF 0xBD, W
00FD  00C4     MOVWF 0xC4
00FE  083E     MOVF 0xBE, W
00FF  1803     BTFSC 0x83, 0x0
0100  0A3E     INCF 0xBE, W
0101  00C5     MOVWF 0xC5
351:               
352:               return c;
0102  00B6     MOVWF 0xB6
0103  0844     MOVF 0xC4, W
0104  00B5     MOVWF 0xB5
353:                
354:           } // ReadFAT
0105  0008     RETURN
355:           
356:           
357:           //-------------------------------------------------------------
358:           // Get Next Cluster
359:           //
360:           unsigned NextFAT( MFILE * fp, unsigned n)
0032  00D4     MOVWF fp
361:           // fp   file structure
362:           // n    number of links in FAT cluster chain to jump through
363:           //      n==1, next cluster in the chain
364:           {
365:               unsigned    c;
366:               MEDIA * mda = fp->mda;
0033  0086     MOVWF 0x86
0034  3001     MOVLW 0x1
0035  0087     MOVWF 0x87
0036  3F42     MOVIW [2]FSR1
0037  00D1     MOVWF 0xD1
367:           
368:               // loop n times
369:               do {
370:                   // get the next cluster link from FAT
371:                   c = ReadFAT( fp, fp->ccls);
0038  0854     MOVF fp, W
0039  3E05     ADDLW 0x5
003A  0086     MOVWF 0x86
003B  3001     MOVLW 0x1
003C  0087     MOVWF 0x87
003D  3F40     MOVIW [0]FSR1
003E  00B5     MOVWF 0xB5
003F  3F41     MOVIW [1]FSR1
0040  00B6     MOVWF 0xB6
0041  0854     MOVF fp, W
0042  207D     CALL 0x7D
0043  3180     MOVLP 0x0
0044  0836     MOVF 0xB6, W
0045  00D3     MOVWF 0xD3
0046  0835     MOVF 0xB5, W
0047  00D2     MOVWF 0xD2
372:           
373:                   // compare against max value of a cluster in FATxx
374:                   // return if eof
375:                   if ( c >= FAT_MCLST)    // check against eof
0048  30FF     MOVLW 0xFF
0049  0253     SUBWF 0xD3, W
004A  30F8     MOVLW 0xF8
004B  1903     BTFSC 0x83, 0x2
004C  0252     SUBWF 0xD2, W
004D  1C03     BTFSS 0x83, 0x0
004E  2858     GOTO 0x58
376:                   {
377:                       FError = FE_FAT_EOF;
004F  3009     MOVLW 0x9
0050  2852     GOTO 0x52
378:                       return FAIL;    // seeking beyond EOF
0054  0020     MOVLB 0x0
0055  01CD     CLRF n
0056  01CE     CLRF 0x4E
0057  0008     RETURN
379:                   }
380:           
381:                   // check if cluster value is valid
382:                   if ( c >= mda->maxcls)
0058  0851     MOVF mda, W
0059  3E0F     ADDLW 0xF
005A  0086     MOVWF FSR1
005B  3001     MOVLW 0x1
005C  0087     MOVWF FSR1H
005D  3F40     MOVIW [0]FSR1
005E  00CF     MOVWF 0x4F
005F  3F41     MOVIW [1]FSR1
0060  00D0     MOVWF 0x50
0061  0253     SUBWF a, W
0062  1D03     BTFSS STATUS, 0x2
0063  2866     GOTO 0x66
0064  084F     MOVF 0x4F, W
0065  0252     SUBWF c, W
0066  1803     BTFSC STATUS, 0x0
0067  2851     GOTO 0x51
383:                   {
384:                       FError = FE_INVALID_CLUSTER;
0051  300B     MOVLW 0xB
0052  0021     MOVLB 0x1
0053  00DC     MOVWF FError
385:                       return FAIL;
386:                   }
387:           
388:               } while (--n > 0);// loop end
0068  3001     MOVLW 0x1
0069  02CD     SUBWF 0xCD, F
006A  3000     MOVLW 0x0
006B  3BCE     SUBWFB 0xCE, F
006C  084D     MOVF 0xCD, W
006D  044E     IORWF 0xCE, W
006E  1D03     BTFSS 0x83, 0x2
006F  2838     GOTO 0x38
389:           
390:               // update the MFILE structure
391:               fp->ccls = c;
0070  0854     MOVF fp, W
0071  3E05     ADDLW 0x5
0072  0086     MOVWF 0x86
0073  3001     MOVLW 0x1
0074  0087     MOVWF 0x87
0075  0852     MOVF 0xD2, W
0076  3FC0     MOVWI [0]FSR1
0077  0853     MOVF 0xD3, W
0078  3FC1     MOVWI [1]FSR1
392:           
393:               return TRUE;
0079  01CD     CLRF 0xCD
007A  0ACD     INCF 0xCD, F
007B  01CE     CLRF 0xCE
394:           } // NextFAT
007C  0008     RETURN
395:           
396:           
397:           #ifdef _WRITE_ENABLED
398:           //-------------------------------------------------------------
399:           // Find a New entry in root directory or an empty entry
400:           //
401:           unsigned NewDIR( MFILE *fp)
402:           // fp       file structure
403:           // return   found/fail,  fp->entry filled
404:           {
405:               unsigned eCount;            // current entry counter
406:               unsigned e;                 // current entry offset
407:               int a;
408:               MEDIA *mda = fp->mda;
409:           
410:               // 1. start from the first entry
411:               eCount = 0;
412:               // load the first sector of root
413:               if ( !ReadDIR( fp, eCount))
414:                   return FAIL;
415:           
416:               // 2. loop until you reach the end or find the file
417:               while ( 1)
418:               {
419:               // 2.0 determine the offset in current buffer
420:                   e = (eCount&0xf) * DIR_ESIZE;
421:           
422:               // 2.1 read the first char of the file name
423:                   a = fp->buffer[ e + DIR_NAME];
424:           
425:               // 2.2 terminate if it is empty (end of the list)or deleted
426:                   if (( a == DIR_EMPTY) ||( a == DIR_DEL))
427:                   {
428:                       fp->entry = eCount;
429:                       return FOUND;
430:                   } // empty or deleted entry found
431:           
432:           
433:               // 2.3 get the next entry
434:                   eCount++;
435:                   if ( (eCount & 0xf) == 0)
436:                   { // load a new sector from the root
437:                       if ( !ReadDIR( fp, eCount))
438:                           return FAIL;
439:                   }
440:           
441:               // 2.4 exit the loop if reached the end or error
442:                   if ( eCount > mda->maxroot)
443:                       return NOT_FOUND;       // last entry reached
444:               }// while
445:           
446:               return FAIL;
447:           } // NewDIR
448:           
449:           //-------------------------------------------------------------
450:           // Write a cluster link in all FAT copies
451:           //
452:           unsigned WriteFAT( MFILE *fp, unsigned cls, unsigned v)
453:           // mda      disk structure
454:           // cls      current cluster 
455:           // v        next value
456:           // return   TRUE if successful, or FAIL
457:           {
458:               int i;
459:               unsigned p;
460:               LBA l;
461:               
462:               // load the FAT page containing the requested cluster
463:               ReadFAT( fp, cls);
464:               
465:               // cluster = 0xabcd
466:               // packed as:     0   |   1    |   2   |  3    |
467:               // word p       0   1 |  2   3 | 4   5 | 6   7 |..
468:               //              cd  ab|  cd  ab| cd  ab| cd  ab| 
469:                  
470:               // locate the cluster within the FAT page
471:               p = (cls & 0xff)*2;    // 2 bytes per cluster 
472:           
473:               // get the next cluster value
474:               fp->buffer[ p] = v;       // lsb 
475:               fp->buffer[ p+1] = (v>>8);// msb
476:               
477:               // update all FAT copies
478:               l = fp->mda->fat + (cls>>8);
479:               for ( i=0; i<fp->mda->fatcopy; i++, l += fp->mda->fatsize)
480:                  if ( !WriteSECTOR( l, fp->buffer))
481:                      return FAIL; 
482:               
483:               return TRUE;
484:                
485:           } // WriteFAT
486:           
487:           
488:           //-------------------------------------------------------------
489:           // Allocate New Cluster
490:           //
491:           unsigned NewFAT( MFILE * fp)
492:           // fp       file structure
493:           // fp->ccls     ==0 if first cluster to be allocated
494:           //              !=0 if additional cluster 
495:           // return   TRUE/FAIL
496:           //  fp->ccls new cluster number 
497:           {
498:               unsigned i, c = fp->ccls;
499:               
500:               // sequentially scan through the FAT 
501:               //    looking for an empty cluster
502:               do {
503:                   c++;    // check next cluster in FAT
504:                   // check if reached last cluster in FAT, 
505:                   // re-start from top
506:                   if ( c >= fp->mda->maxcls)
507:                       c = 0;  
508:                       
509:                   // check if full circle done, media full
510:                   if ( c == fp->ccls)
511:                   {
512:                       FError = FE_MEDIA_FULL;
513:                       return FAIL;
514:                   }
515:                       
516:                   // look at its value 
517:                   i = ReadFAT( fp, c);
518:                       
519:               } while ( i!=0);    // scanning for an empty cluster
520:               
521:               // mark the new cluster as taken, and last in chain
522:               WriteFAT( fp, c, FAT_EOF);
523:               
524:               // if not first cluster, link current cluster to new one
525:               if ( fp->ccls >0)
526:                   WriteFAT( fp, fp->ccls, c);
527:               
528:               // update the MFILE structure
529:               fp->ccls = c;
530:               
531:               // invalidate the FAT cache 
532:               //   (since it will soon be overwritten with data)
533:               fp->fpage = -1;
534:                   
535:               return TRUE;
536:           } // NewFAT
537:           
538:           
539:           //-------------------------------------------------------------
540:           //
541:           unsigned WriteDATA( MFILE *fp)
542:           {
543:               LBA l;
544:           
545:               // calculate lba of cluster/sector
546:               l = fp->mda->data+(LBA)(fp->ccls-2) * fp->mda->sxc+fp->sec;
547:           
548:               return ( WriteSECTOR( l, fp->buffer));
549:           
550:           } // WriteDATA
551:           
552:           #endif
553:           
554:           
555:           //-------------------------------------------------------------
556:           //
557:           unsigned ReadDATA( MFILE *fp)
0F53  00C7     MOVWF 0xC7
558:           {
559:               LBA l;
560:           
561:               // calculate lba of cluster/sector
562:               l = fp->mda->data+(LBA)(fp->ccls-2) * fp->mda->sxc+fp->sec;
0F54  3E02     ADDLW 0x2
0F55  0086     MOVWF 0x86
0F56  3001     MOVLW 0x1
0F57  0087     MOVWF 0x87
0F58  0801     MOVF 0x81, W
0F59  3E09     ADDLW 0x9
0F5A  0086     MOVWF 0x86
0F5B  3F40     MOVIW [0]FSR1
0F5C  00B7     MOVWF 0xB7
0F5D  3F41     MOVIW [1]FSR1
0F5E  00B8     MOVWF 0xB8
0F5F  3F42     MOVIW [2]FSR1
0F60  00B9     MOVWF 0xB9
0F61  3F43     MOVIW [3]FSR1
0F62  00BA     MOVWF 0xBA
0F63  0847     MOVF 0xC7, W
0F64  3E07     ADDLW 0x7
0F65  0086     MOVWF 0x86
0F66  3F40     MOVIW [0]FSR1
0F67  00BB     MOVWF 0xBB
0F68  3F41     MOVIW [1]FSR1
0F69  00BC     MOVWF 0xBC
0F6A  083B     MOVF 0xBB, W
0F6B  00BD     MOVWF 0xBD
0F6C  083C     MOVF 0xBC, W
0F6D  00BE     MOVWF 0xBE
0F6E  01BF     CLRF 0xBF
0F6F  01C0     CLRF fp
0F70  0847     MOVF 0xC7, W
0F71  3E05     ADDLW 0x5
0F72  0086     MOVWF 0x86
0F73  3F40     MOVIW [0]FSR1
0F74  00C1     MOVWF ck
0F75  3F41     MOVIW [1]FSR1
0F76  00C2     MOVWF 0xC2
0F77  0841     MOVF ck, W
0F78  3EFE     ADDLW 0xFE
0F79  00A0     MOVWF __pcstackBANK1
0F7A  30FF     MOVLW 0xFF
0F7B  3D42     ADDWFC 0xC2, W
0F7C  00A1     MOVWF r
0F7D  01A2     CLRF 0xA2
0F7E  01A3     CLRF fp
0F7F  0847     MOVF 0xC7, W
0F80  3E02     ADDLW 0x2
0F81  0086     MOVWF 0x86
0F82  0801     MOVF 0x81, W
0F83  3E14     ADDLW 0x14
0F84  0086     MOVWF 0x86
0F85  0801     MOVF 0x81, W
0F86  00A4     MOVWF 0xA4
0F87  01A5     CLRF lc
0F88  01A6     CLRF 0xA6
0F89  01A7     CLRF 0xA7
0F8A  27C2     CALL 0x7C2
0F8B  3188     MOVLP 0x8
0F8C  0820     MOVF __pcstackBANK1, W
0F8D  07BD     ADDWF 0xBD, F
0F8E  0821     MOVF r, W
0F8F  3DBE     ADDWFC 0xBE, F
0F90  0822     MOVF 0xA2, W
0F91  3DBF     ADDWFC 0xBF, F
0F92  0823     MOVF fp, W
0F93  3DC0     ADDWFC fp, F
0F94  083D     MOVF 0xBD, W
0F95  07B7     ADDWF 0xB7, F
0F96  083E     MOVF 0xBE, W
0F97  3DB8     ADDWFC 0xB8, F
0F98  083F     MOVF 0xBF, W
0F99  3DB9     ADDWFC 0xB9, F
0F9A  0840     MOVF fp, W
0F9B  3DBA     ADDWFC 0xBA, F
0F9C  083A     MOVF 0xBA, W
0F9D  00C6     MOVWF 0xC6
0F9E  0839     MOVF 0xB9, W
0F9F  00C5     MOVWF 0xC5
0FA0  0838     MOVF 0xB8, W
0FA1  00C4     MOVWF 0xC4
0FA2  0837     MOVF 0xB7, W
0FA3  00C3     MOVWF 0xC3
563:               fp->fpage = -1;         // invalidate FAT cache
0FA4  0847     MOVF 0xC7, W
0FA5  3E25     ADDLW 0x25
0FA6  0086     MOVWF 0x86
0FA7  3001     MOVLW 0x1
0FA8  0087     MOVWF 0x87
0FA9  30FF     MOVLW 0xFF
0FAA  3FC0     MOVWI [0]FSR1
0FAB  3FC1     MOVWI [1]FSR1
564:               
565:               return( ReadSECTOR( l, fp->buffer));
0FAC  0846     MOVF 0xC6, W
0FAD  00A9     MOVWF skip
0FAE  0845     MOVF 0xC5, W
0FAF  00A8     MOVWF 0xA8
0FB0  0844     MOVF 0xC4, W
0FB1  00A7     MOVWF 0xA7
0FB2  0843     MOVF 0xC3, W
0FB3  00A6     MOVWF 0xA6
0FB4  0847     MOVF 0xC7, W
0FB5  0086     MOVWF 0x86
0FB6  3F40     MOVIW [0]FSR1
0FB7  00AA     MOVWF size
0FB8  3F41     MOVIW [1]FSR1
0FB9  00AB     MOVWF stereo
0FBA  3182     MOVLP 0x2
0FBB  22D7     CALL 0x2D7
0FBC  0827     MOVF 0xA7, W
0FBD  00B6     MOVWF 0xB6
0FBE  0826     MOVF 0xA6, W
0FBF  00B5     MOVWF 0xB5
566:           
567:           } // ReadDATA
0FC0  0008     RETURN
568:           
569:            
570:           //-------------------------------------------------------------
571:           // Open File on the default storage device D
572:           //
573:           MFILE *fopenM( const char *filename, const char *mode)
574:           {
575:               char c;
576:               int i, r, e;
577:               unsigned char *b;       
578:               MFILE *fp;              
579:           
580:               // 1.  check if storage device is mounted 
581:               if ( D == NULL)       // unmounted
582:               {
583:                   FError = FE_MEDIA_NOT_MNTD;
584:                   return NULL;
585:               }
586:               
587:               // 2. allocate a buffer for the file
588:               b = &B[ D->cb];
589:               
590:               // 3. allocate a MFILE structure on the heap
591:               fp = &F[0];
592:               
593:               // 4. set pointers to the MEDIA structure and buffer
594:               fp->mda = D;
595:               fp->buffer = b;
596:           
597:               // 5. format the filename into name 
598:               for( i=0; i<8; i++)
599:               {
600:                   // read a char and convert to upper case
601:                   c = toupper( *filename++);      
602:                   // extension or short name no-extension
603:                   if (( c == '.') || ( c == '\0'))
604:                       break;
605:                   else 
606:                       fp->name[i] = c;
607:               } // for
608:               // if short fill the rest up to 8 with spaces
609:               while ( i<8) fp->name[i++] = ' ';
610:           
611:               // 6. if there is an extension
612:               if ( c != '\0') 
613:               {    
614:                   for( i=8; i<11; i++)
615:                   {
616:                       // read a char and convert to upper case
617:                       c = toupper( *filename++);      
618:                       if ( c == '.')
619:                           c = toupper( *filename++);
620:                       if ( c == '\0')                 // short extension
621:                           break;
622:                       else 
623:                           fp->name[i] = c;
624:                   } // for
625:                   // if short fill the rest up to 3 with spaces
626:                   while ( i<11) fp->name[i++] = ' ';
627:               } // if
628:           
629:               // 7. copy the file mode character  (r, w) 
630:               if ((*mode == 'r')||(*mode == 'w'))
631:                   fp->mode = *mode;
632:               else
633:               { 
634:                   FError = FE_INVALID_MODE;
635:                   goto ExitOpen;
636:               }
637:           
638:               // 8. Search for the file in current directory
639:               if ( ( r = FindDIR( fp)) == FAIL)
640:               { 
641:                   FError = FE_FIND_ERROR;
642:                   goto ExitOpen;
643:               }
644:               
645:               // 9. init all counters to the beginning of the file
646:               fp->seek = 0;               // first byte in file
647:               fp->sec = 0;                // first sector in the cluster
648:               fp->pos = 0;                // first byte in sector/cluster
649:               
650:               // 10. depending on the mode (read or write) 
651:               if ( fp->mode == 'r') 
652:               {   // 10.1 'r' open for reading
653:                   if  ( r == NOT_FOUND)
654:                   {
655:                       FError = FE_FILE_NOT_FOUND;
656:                       goto ExitOpen;
657:                   }
658:                   else
659:                   {  // found             
660:                   // 10.2 set current cluster pointer on first cluster
661:                       fp->ccls = fp->cluster;     
662:           
663:                   // 10.3 read a sector of data from the file
664:                       if ( !ReadDATA( fp))
665:                       {
666:                           goto ExitOpen;
667:                       }
668:                   
669:                   // 10.4 determine how much data is really inside buffer
670:                       if ( fp->size-fp->seek < 512)
671:                           fp->top = fp->size - fp->seek;
672:                       else
673:                           fp->top = 512;
674:                   } // found
675:               } // 'r' 
676:           
677:           #ifdef _WRITE_ENABLED
678:               else // 11.  open for 'write'
679:               { 
680:                   if  ( r == NOT_FOUND)
681:                   {
682:                       // 11.1 allocate a first cluster to it
683:                       fp->ccls = 0;            // indicate brand new file
684:                       if ( NewFAT( fp) != TRUE)
685:                       { // must be media full 
686:                           FError = FE_MEDIA_FULL;
687:                           goto ExitOpen;
688:                       }
689:                       fp->cluster = fp->ccls; 
690:           
691:                       // 11.2 create a new entry
692:                       // search again, for an empty entry this time
693:                       if ( (r = NewDIR( fp)) == FAIL)
694:                       {   // report any error
695:                           FError = FE_IDE_ERROR;
696:                           goto ExitOpen;
697:                       }
698:                       // 11.3 new entry not found 
699:                       if ( r == NOT_FOUND)
700:                       { 
701:                           FError = FE_DIR_FULL;
702:                           goto ExitOpen;
703:                       }
704:                       else // 11.4 new entry identified fp->entry filled 
705:                       {
706:                           // 11.4.1
707:                           fp->size = 0;
708:           
709:                           // 11.4.2    determine offset in DIR sector
710:                           e = (fp->entry & 0xf) * DIR_ESIZE;    
711:                   
712:                           // 11.4.3 init all fields to 0
713:                           for (i=0; i<32; i++)
714:                                   fp->buffer[ e + i]  = 0;
715:                   
716:                           // 11.4.4 set date and time
717:                           fp->date = 0x378A; // Dec 10th, 2007
718:                           fp->buffer[ e + DIR_CDATE]  = fp->date;
719:                           fp->buffer[ e + DIR_CDATE+1]= fp->date>>8;
720:                           fp->buffer[ e + DIR_DATE]  = fp->date;
721:                           fp->buffer[ e + DIR_DATE+1]= fp->date>>8;
722:           
723:                           fp->time = 0x6000; // 12:00:00 PM
724:                           fp->buffer[ e + DIR_CTIME]  = fp->time;
725:                           fp->buffer[ e + DIR_CTIME+1]= fp->time>>8;
726:                           fp->buffer[ e + DIR_TIME]  = fp->time+1;
727:                           fp->buffer[ e + DIR_TIME+1]= fp->time>>8;
728:                   
729:                           // 11.4.5 set first cluster
730:                           fp->buffer[ e + DIR_CLST]  = fp->cluster;
731:                           fp->buffer[ e + DIR_CLST+1]= (fp->cluster>>8);
732:                           
733:                           // 11.4.6 set name
734:                           for ( i = 0; i<DIR_ATTRIB; i++)
735:                               fp->buffer[ e + i] = fp->name[i];
736:                           
737:                           // 11.4.7 set attrib
738:                           fp->buffer[ e + DIR_ATTRIB] = ATT_ARC;
739:                           
740:                           // 11.4.8  update the directory sector;
741:                           if ( !WriteDIR( fp, fp->entry))
742:                           {
743:                               FError = FE_IDE_ERROR;
744:                               goto ExitOpen;
745:                           }
746:                       } // new entry
747:                   } // not found
748:           
749:                   else // file exist already, report error
750:                   {
751:                       FError = FE_FILE_OVERWRITE;
752:                       goto ExitOpen;
753:                   }
754:                       
755:               } // w request
756:           #endif
757:               
758:               // 12. Exit with success    
759:               return fp;
760:           
761:               // 13. Exit with error
762:           ExitOpen:
763:           //    free( fp->buffer);
764:           //    free( fp);
765:               return NULL;
766:                   
767:           } // fopenM
768:           
769:           
770:           //-------------------------------------------------------------
771:           // Read File
772:           //
773:           // returns      number of bytes actually transferred
774:           //
775:           unsigned freadM( char * dest, unsigned size, MFILE *fp)
776:           // fp       pointer to MFILE structure
777:           // dest     pointer to destination buffer
778:           // count    number of bytes to transfer
779:           // returns  number of bytes actually transferred
780:           {
781:               MEDIA * mda = fp->mda;      
0DCE  0859     MOVF AEmptyFlag, W
0DCF  0086     MOVWF 0x86
0DD0  3001     MOVLW 0x1
0DD1  0087     MOVWF 0x87
0DD2  3F42     MOVIW [2]FSR1
0DD3  00E3     MOVWF 0xE3
782:               unsigned count=size;        // counts bytes to be transfer
0DD4  0858     MOVF 0xD8, W
0DD5  00E5     MOVWF 0xE5
0DD6  0857     MOVF BPtr, W
0DD7  00E4     MOVWF 0xE4
783:               unsigned len;          
784:               
785:           
786:               // 1. check if fp points to a valid open file structure
787:               if (( fp->mode != 'r')) 
0DD8  0859     MOVF AEmptyFlag, W
0DD9  3E24     ADDLW 0x24
0DDA  0086     MOVWF 0x86
0DDB  3072     MOVLW 0x72
0DDC  0601     XORWF 0x81, W
0DDD  1903     BTFSC 0x83, 0x2
0DDE  2F47     GOTO 0x747
788:               {   // invalid file or not open in read mode
789:                   FError = FE_INVALID_FILE; 
0DDF  3008     MOVLW 0x8
0DE0  0021     MOVLB 0x1
0DE1  00DC     MOVWF FError
790:                   return 0;
0DE2  0020     MOVLB 0x0
0DE3  01D5     CLRF dest
0DE4  01D6     CLRF fp
0DE5  0008     RETURN
791:               }
792:           
793:               // 2. loop to transfer the data
794:               while ( count>0)
0F47  0864     MOVF count, W
0F48  0465     IORWF 0x65, W
0F49  1D03     BTFSS STATUS, 0x2
0F4A  2DE6     GOTO 0x5E6
795:               {               
796:           
797:                   // 2.1 check if EOF reached 
798:                   if ( fp->seek >= fp->size)
0DE6  0859     MOVF fp, W
0DE7  3E11     ADDLW 0x11
0DE8  0086     MOVWF FSR1
0DE9  3001     MOVLW 0x1
0DEA  0087     MOVWF FSR1H
0DEB  3F40     MOVIW [0]FSR1
0DEC  00DA     MOVWF 0x5A
0DED  3F41     MOVIW [1]FSR1
0DEE  00DB     MOVWF 0x5B
0DEF  3F42     MOVIW [2]FSR1
0DF0  00DC     MOVWF 0x5C
0DF1  3F43     MOVIW [3]FSR1
0DF2  00DD     MOVWF 0x5D
0DF3  0859     MOVF fp, W
0DF4  3E0D     ADDLW 0xD
0DF5  0086     MOVWF FSR1
0DF6  3F40     MOVIW [0]FSR1
0DF7  00DE     MOVWF 0x5E
0DF8  3F41     MOVIW [1]FSR1
0DF9  00DF     MOVWF 0x5F
0DFA  3F42     MOVIW [2]FSR1
0DFB  00E0     MOVWF 0x60
0DFC  3F43     MOVIW [3]FSR1
0DFD  00E1     MOVWF 0x61
0DFE  3A80     XORLW 0x80
0DFF  00E2     MOVWF 0x62
0E00  085D     MOVF 0x5D, W
0E01  3A80     XORLW 0x80
0E02  0262     SUBWF 0x62, W
0E03  1D03     BTFSS STATUS, 0x2
0E04  2E0F     GOTO 0x60F
0E05  085C     MOVF 0x5C, W
0E06  0260     SUBWF 0x60, W
0E07  1D03     BTFSS STATUS, 0x2
0E08  2E0F     GOTO 0x60F
0E09  085B     MOVF 0x5B, W
0E0A  025F     SUBWF 0x5F, W
0E0B  1D03     BTFSS STATUS, 0x2
0E0C  2E0F     GOTO 0x60F
0E0D  085A     MOVF 0x5A, W
0E0E  025E     SUBWF 0x5E, W
0E0F  1C03     BTFSS STATUS, 0x0
0E10  2E15     GOTO 0x615
799:                   {
800:                       FError = FE_EOF;  // reached the end
0E11  300A     MOVLW 0xA
0E12  0021     MOVLB 0x1
0E13  00DC     MOVWF FError
801:                       break;
0E14  2F4B     GOTO 0x74B
802:                   }
803:                   
804:                   // 2.2 load a new sector if necessary
805:                   if (fp->pos == fp->top) 
0E15  0859     MOVF AEmptyFlag, W
0E16  3E0B     ADDLW 0xB
0E17  0086     MOVWF 0x86
0E18  3001     MOVLW 0x1
0E19  0087     MOVWF 0x87
0E1A  3F40     MOVIW [0]FSR1
0E1B  00DA     MOVWF BCount
0E1C  3F41     MOVIW [1]FSR1
0E1D  00DB     MOVWF D
0E1E  0859     MOVF AEmptyFlag, W
0E1F  3E09     ADDLW 0x9
0E20  0086     MOVWF 0x86
0E21  3F40     MOVIW [0]FSR1
0E22  00DC     MOVWF FError
0E23  3F41     MOVIW [1]FSR1
0E24  00DD     MOVWF TMR2_InterruptHandler
0E25  065B     XORWF D, W
0E26  1D03     BTFSS 0x83, 0x2
0E27  2E2A     GOTO 0x62A
0E28  085A     MOVF BCount, W
0E29  065C     XORWF FError, W
0E2A  1D03     BTFSS 0x83, 0x2
0E2B  2EBD     GOTO 0x6BD
806:                   {   
807:                       fp->pos = 0;
0E2C  0859     MOVF AEmptyFlag, W
0E2D  3E09     ADDLW 0x9
0E2E  0086     MOVWF 0x86
0E2F  3001     MOVLW 0x1
0E30  0087     MOVWF 0x87
0E31  3000     MOVLW 0x0
0E32  3FC0     MOVWI [0]FSR1
0E33  3FC1     MOVWI [1]FSR1
808:                       fp->sec++;
0E34  0859     MOVF AEmptyFlag, W
0E35  3E07     ADDLW 0x7
0E36  0086     MOVWF 0x86
0E37  3001     MOVLW 0x1
0E38  0781     ADDWF 0x81, F
0E39  3141     ADDFSR 1, 1
0E3A  1803     BTFSC 0x83, 0x0
0E3B  0A81     INCF 0x81, F
809:                       
810:                       // 2.2.1 get a new cluster if necessary
811:                       if ( fp->sec == mda->sxc)
0E3C  0859     MOVF AEmptyFlag, W
0E3D  3E07     ADDLW 0x7
0E3E  0086     MOVWF 0x86
0E3F  3001     MOVLW 0x1
0E40  0087     MOVWF 0x87
0E41  3F40     MOVIW [0]FSR1
0E42  00DA     MOVWF BCount
0E43  3F41     MOVIW [1]FSR1
0E44  00DB     MOVWF D
0E45  0863     MOVF 0xE3, W
0E46  3E14     ADDLW 0x14
0E47  0086     MOVWF 0x86
0E48  0801     MOVF 0x81, W
0E49  00DC     MOVWF FError
0E4A  01DD     CLRF TMR2_InterruptHandler
0E4B  085B     MOVF D, W
0E4C  065D     XORWF TMR2_InterruptHandler, W
0E4D  1D03     BTFSS 0x83, 0x2
0E4E  2E51     GOTO 0x651
0E4F  085A     MOVF BCount, W
0E50  065C     XORWF FError, W
0E51  1D03     BTFSS 0x83, 0x2
0E52  2E66     GOTO 0x666
812:                       {
813:                           fp->sec = 0;
0E53  0859     MOVF AEmptyFlag, W
0E54  3E07     ADDLW 0x7
0E55  0086     MOVWF 0x86
0E56  3001     MOVLW 0x1
0E57  0087     MOVWF 0x87
0E58  3000     MOVLW 0x0
0E59  3FC0     MOVWI [0]FSR1
0E5A  3FC1     MOVWI [1]FSR1
814:           //                fp->ccls++;       // HACK!
815:                           if ( !NextFAT( fp, 1))
0E5B  01CD     CLRF 0xCD
0E5C  0ACD     INCF 0xCD, F
0E5D  01CE     CLRF 0xCE
0E5E  0859     MOVF AEmptyFlag, W
0E5F  3180     MOVLP 0x0
0E60  2032     CALL 0x32
0E61  3188     MOVLP 0x8
0E62  084D     MOVF 0xCD, W
0E63  044E     IORWF 0xCE, W
0E64  1903     BTFSC 0x83, 0x2
0E65  2F4B     GOTO 0x74B
816:                               break;
817:                       }
818:                       // 2.2.2 load a sector of data
819:                       if ( !ReadDATA( fp))
0E66  0859     MOVF AEmptyFlag, W
0E67  2753     CALL 0x753
0E68  3188     MOVLP 0x8
0E69  0835     MOVF 0xB5, W
0E6A  0436     IORWF 0xB6, W
0E6B  1903     BTFSC 0x83, 0x2
0E6C  2F4B     GOTO 0x74B
820:                           break;
821:           
822:                       // 2.2.3 determine how much data is inside buffer
823:                       if ( fp->size-fp->seek < 512)
0E6D  0859     MOVF AEmptyFlag, W
0E6E  3E0D     ADDLW 0xD
0E6F  0086     MOVWF 0x86
0E70  3001     MOVLW 0x1
0E71  0087     MOVWF 0x87
0E72  3F40     MOVIW [0]FSR1
0E73  00DA     MOVWF BCount
0E74  3F41     MOVIW [1]FSR1
0E75  00DB     MOVWF D
0E76  3F42     MOVIW [2]FSR1
0E77  00DC     MOVWF FError
0E78  3F43     MOVIW [3]FSR1
0E79  00DD     MOVWF TMR2_InterruptHandler
0E7A  0859     MOVF AEmptyFlag, W
0E7B  3E11     ADDLW 0x11
0E7C  0086     MOVWF 0x86
0E7D  3F40     MOVIW [0]FSR1
0E7E  00DE     MOVWF 0xDE
0E7F  3F41     MOVIW [1]FSR1
0E80  00DF     MOVWF __pdataBANK1
0E81  3F42     MOVIW [2]FSR1
0E82  00E0     MOVWF 0xE0
0E83  3F43     MOVIW [3]FSR1
0E84  00E1     MOVWF 0xE1
0E85  085A     MOVF BCount, W
0E86  02DE     SUBWF 0xDE, F
0E87  085B     MOVF D, W
0E88  3BDF     SUBWFB __pdataBANK1, F
0E89  085C     MOVF FError, W
0E8A  3BE0     SUBWFB 0xE0, F
0E8B  085D     MOVF TMR2_InterruptHandler, W
0E8C  3BE1     SUBWFB 0xE1, F
0E8D  1BE1     BTFSC 0xE1, 0x7
0E8E  2E99     GOTO 0x699
0E8F  0861     MOVF 0xE1, W
0E90  1D03     BTFSS 0x83, 0x2
0E91  2EB4     GOTO 0x6B4
0E92  0860     MOVF 0xE0, W
0E93  1D03     BTFSS 0x83, 0x2
0E94  2EB4     GOTO 0x6B4
0E95  3002     MOVLW 0x2
0E96  025F     SUBWF __pdataBANK1, W
0E97  1803     BTFSC 0x83, 0x0
0E98  2EB4     GOTO 0x6B4
824:                           fp->top = fp->size - fp->seek;
0E99  0859     MOVF AEmptyFlag, W
0E9A  3E0D     ADDLW 0xD
0E9B  0086     MOVWF 0x86
0E9C  3001     MOVLW 0x1
0E9D  0087     MOVWF 0x87
0E9E  0859     MOVF AEmptyFlag, W
0E9F  3E11     ADDLW 0x11
0EA0  0084     MOVWF 0x84
0EA1  3001     MOVLW 0x1
0EA2  0085     MOVWF 0x85
0EA3  3F40     MOVIW [0]FSR1
0EA4  0200     SUBWF 0x80, W
0EA5  00DA     MOVWF BCount
0EA6  3101     ADDFSR 0, 1
0EA7  3F41     MOVIW [1]FSR1
0EA8  3B00     SUBWFB 0x80, W
0EA9  00DB     MOVWF D
0EAA  0859     MOVF AEmptyFlag, W
0EAB  3E0B     ADDLW 0xB
0EAC  0086     MOVWF 0x86
0EAD  3001     MOVLW 0x1
0EAE  0087     MOVWF 0x87
0EAF  085A     MOVF BCount, W
0EB0  3FC0     MOVWI [0]FSR1
0EB1  085B     MOVF D, W
0EB2  3FC1     MOVWI [1]FSR1
0EB3  2EBD     GOTO 0x6BD
825:                       else
826:                           fp->top = 512;
0EB4  0859     MOVF AEmptyFlag, W
0EB5  3E0B     ADDLW 0xB
0EB6  0086     MOVWF 0x86
0EB7  3001     MOVLW 0x1
0EB8  0087     MOVWF 0x87
0EB9  3000     MOVLW 0x0
0EBA  3FC0     MOVWI [0]FSR1
0EBB  3002     MOVLW 0x2
0EBC  3FC1     MOVWI [1]FSR1
827:                    } //  load new sector
828:           
829:                   // 2.3 copy as many bytes as possible in a single chunk
830:                   // take as much as fits in the current sector
831:                   if ( fp->pos+count < fp->top)
0EBD  0859     MOVF AEmptyFlag, W
0EBE  3E0B     ADDLW 0xB
0EBF  0086     MOVWF 0x86
0EC0  3001     MOVLW 0x1
0EC1  0087     MOVWF 0x87
0EC2  3F40     MOVIW [0]FSR1
0EC3  00DA     MOVWF BCount
0EC4  3F41     MOVIW [1]FSR1
0EC5  00DB     MOVWF D
0EC6  0859     MOVF AEmptyFlag, W
0EC7  3E09     ADDLW 0x9
0EC8  0086     MOVWF 0x86
0EC9  3F40     MOVIW [0]FSR1
0ECA  00DC     MOVWF FError
0ECB  3F41     MOVIW [1]FSR1
0ECC  00DD     MOVWF TMR2_InterruptHandler
0ECD  0864     MOVF 0xE4, W
0ECE  075C     ADDWF FError, W
0ECF  00DE     MOVWF 0xDE
0ED0  0865     MOVF 0xE5, W
0ED1  3D5D     ADDWFC TMR2_InterruptHandler, W
0ED2  00DF     MOVWF __pdataBANK1
0ED3  085B     MOVF D, W
0ED4  025F     SUBWF __pdataBANK1, W
0ED5  1D03     BTFSS 0x83, 0x2
0ED6  2ED9     GOTO 0x6D9
0ED7  085A     MOVF BCount, W
0ED8  025E     SUBWF 0xDE, W
0ED9  1803     BTFSC 0x83, 0x0
0EDA  2EE0     GOTO 0x6E0
832:                       // fits all in current sector
833:                       len = count;          
0EDB  0865     MOVF 0xE5, W
0EDC  00E7     MOVWF 0xE7
0EDD  0864     MOVF 0xE4, W
0EDE  00E6     MOVWF 0xE6
0EDF  2EF1     GOTO 0x6F1
834:                   else 
835:                       // take a first chunk, there is more
836:                       len = fp->top - fp->pos;    
0EE0  0859     MOVF AEmptyFlag, W
0EE1  3E09     ADDLW 0x9
0EE2  0086     MOVWF 0x86
0EE3  3001     MOVLW 0x1
0EE4  0087     MOVWF 0x87
0EE5  0859     MOVF AEmptyFlag, W
0EE6  3E0B     ADDLW 0xB
0EE7  0084     MOVWF 0x84
0EE8  3001     MOVLW 0x1
0EE9  0085     MOVWF 0x85
0EEA  3F40     MOVIW [0]FSR1
0EEB  0200     SUBWF 0x80, W
0EEC  00E6     MOVWF 0xE6
0EED  3101     ADDFSR 0, 1
0EEE  3F41     MOVIW [1]FSR1
0EEF  3B00     SUBWFB 0x80, W
0EF0  00E7     MOVWF 0xE7
837:           
838:                   // check if dummy read
839:                   if ( dest)
0EF1  0855     MOVF entry, W
0EF2  0456     IORWF 0xD6, W
0EF3  1903     BTFSC 0x83, 0x2
0EF4  2F1D     GOTO 0x71D
840:                       memcpy( dest, fp->buffer + fp->pos, len);
0EF5  0855     MOVF entry, W
0EF6  0086     MOVWF 0x86
0EF7  0856     MOVF 0xD6, W
0EF8  0087     MOVWF 0x87
0EF9  0020     MOVLB 0x0
0EFA  0859     MOVF fp, W
0EFB  3E09     ADDLW 0x9
0EFC  0084     MOVWF FSR0
0EFD  3001     MOVLW 0x1
0EFE  0085     MOVWF FSR0H
0EFF  3F00     MOVIW [0]FSR0
0F00  00DA     MOVWF 0x5A
0F01  3F01     MOVIW [1]FSR0
0F02  00DB     MOVWF 0x5B
0F03  0859     MOVF fp, W
0F04  0084     MOVWF FSR0
0F05  3F00     MOVIW [0]FSR0
0F06  00DC     MOVWF 0x5C
0F07  3F01     MOVIW [1]FSR0
0F08  00DD     MOVWF 0x5D
0F09  085A     MOVF 0x5A, W
0F0A  075C     ADDWF 0x5C, W
0F0B  0084     MOVWF FSR0
0F0C  085B     MOVF 0x5B, W
0F0D  3D5D     ADDWFC 0x5D, W
0F0E  0085     MOVWF FSR0H
0F0F  0867     MOVF 0x67, W
0F10  00DF     MOVWF 0x5F
0F11  0866     MOVF len, W
0F12  00DE     MOVWF 0x5E
0F13  0012     MOVIW FSR0++
0F14  001E     MOVWI FSR1++
0F15  3001     MOVLW 0x1
0F16  02DE     SUBWF 0x5E, F
0F17  3000     MOVLW 0x0
0F18  3BDF     SUBWFB 0x5F, F
0F19  085F     MOVF 0x5F, W
0F1A  045E     IORWF 0x5E, W
0F1B  1D03     BTFSS STATUS, 0x2
0F1C  2F13     GOTO 0x713
841:           
842:                   // 2.4 update all counters and pointers
843:                   count-= len;            // compute what is left
0F1D  0020     MOVLB 0x0
0F1E  0866     MOVF len, W
0F1F  02E4     SUBWF count, F
0F20  0867     MOVF 0x67, W
0F21  3BE5     SUBWFB 0x65, F
844:                   dest += len;            // advance destination pointer
0F22  0866     MOVF len, W
0F23  07D5     ADDWF dest, F
0F24  0867     MOVF 0x67, W
0F25  3DD6     ADDWFC fp, F
845:                   fp->pos += len;         // advance pointer in sector
0F26  0859     MOVF fp, W
0F27  3E09     ADDLW 0x9
0F28  0086     MOVWF FSR1
0F29  3001     MOVLW 0x1
0F2A  0087     MOVWF FSR1H
0F2B  0866     MOVF len, W
0F2C  0781     ADDWF INDF1, F
0F2D  3141     ADDFSR 1, 1
0F2E  0867     MOVF 0x67, W
0F2F  3D81     ADDWFC INDF1, F
0F30  317F     ADDFSR 1, -1
846:                   fp->seek += len;        // advance the seek pointer
0F31  0866     MOVF len, W
0F32  00DA     MOVWF 0x5A
0F33  0867     MOVF 0x67, W
0F34  00DB     MOVWF 0x5B
0F35  01DC     CLRF 0x5C
0F36  01DD     CLRF 0x5D
0F37  0859     MOVF fp, W
0F38  3E0D     ADDLW 0xD
0F39  0086     MOVWF FSR1
0F3A  3001     MOVLW 0x1
0F3B  0087     MOVWF FSR1H
0F3C  085A     MOVF 0x5A, W
0F3D  0781     ADDWF INDF1, F
0F3E  3141     ADDFSR 1, 1
0F3F  085B     MOVF 0x5B, W
0F40  3D81     ADDWFC INDF1, F
0F41  3141     ADDFSR 1, 1
0F42  085C     MOVF 0x5C, W
0F43  3D81     ADDWFC INDF1, F
0F44  3141     ADDFSR 1, 1
0F45  085D     MOVF 0x5D, W
0F46  3D81     ADDWFC INDF1, F
847:                   
848:               } // while count
849:               
850:               // 3. return number of bytes actually transferred 
851:               return size-count;
0F4B  0020     MOVLB 0x0
0F4C  0864     MOVF count, W
0F4D  0257     SUBWF size, W
0F4E  00D5     MOVWF dest
0F4F  0865     MOVF 0x65, W
0F50  3B58     SUBWFB 0x58, W
0F51  00D6     MOVWF fp
852:           
853:           } // freadM
0F52  0008     RETURN
854:           
855:           
856:           //-------------------------------------------------------------
857:           // Close a File
858:           //
859:           unsigned fcloseM( MFILE *fp)
860:           {
861:               unsigned r;
862:           
863:               r = FAIL;
864:           
865:           #ifdef _WRITE_ENABLED
866:               // 1. check if it was open for write
867:               if ( fp->mode == 'w')   
868:               {
869:                   unsigned e;
870:                   
871:                   // 1.1 if the current buffer contains data, flush it
872:                   if ( fp->pos >0)
873:                   {   
874:                       if ( !WriteDATA( fp))
875:                           goto ExitClose; 
876:                   } 
877:                   
878:                   // 1.2      finally update the dir entry, 
879:                   // 1.2.1    retrieve the dir sector
880:                   if ( !ReadDIR( fp, fp->entry))
881:                       goto ExitClose;
882:               
883:                   // 1.2.2    determine position in DIR sector
884:                   e = (fp->entry & 0xf) * DIR_ESIZE;    
885:           
886:                   // 1.2.3 update file size
887:                   fp->buffer[ e + DIR_SIZE]  = fp->size;
888:                   fp->buffer[ e + DIR_SIZE+1]= fp->size>>8;
889:                   fp->buffer[ e + DIR_SIZE+2]= fp->size>>16;
890:                   fp->buffer[ e + DIR_SIZE+3]= fp->size>>24;
891:           
892:                   // 1.2.4    update the directory sector;
893:                   if ( !WriteDIR( fp, fp->entry))
894:                       goto ExitClose;
895:               } // write
896:           #endif
897:               
898:               // 2. exit with success
899:               r = TRUE;
900:           
901:           //ExitClose:
902:           
903:               // 3. free up the buffer and the MFILE struct
904:           //    free( fp->buffer);
905:           //    free( fp);
906:               return( r);
907:               
908:           } // fcloseM
0FC1  0008     RETURN
909:           
910:           
911:           
912:           
913:           //----------------------------------------------------------------------
914:           // fseekM
915:           //
916:           // Advances the file pointer by count positions from CUR_POS
917:           // simple implementation of a seek function
918:           // returns 0 if successfull
919:           
920:           unsigned fseekM( MFILE * fp, unsigned count)
0508  0020     MOVLB 0x0
0509  00EA     MOVWF fp
921:           {
922:               unsigned d, r;
923:           
924:               while ( count)
050A  0868     MOVF lc, W
050B  0469     IORWF 0x69, W
050C  1903     BTFSC STATUS, 0x2
050D  0008     RETURN
925:               {
926:                   d = ( count >= 16) ? 16 : count;
050E  3000     MOVLW 0x0
050F  0269     SUBWF 0x69, W
0510  3010     MOVLW 0x10
0511  1903     BTFSC STATUS, 0x2
0512  0268     SUBWF lc, W
0513  1803     BTFSC STATUS, 0x0
0514  2D1A     GOTO 0x51A
0515  0869     MOVF 0x69, W
0516  00EE     MOVWF 0x6E
0517  0868     MOVF lc, W
0518  00ED     MOVWF d
0519  2D1D     GOTO 0x51D
051A  3010     MOVLW 0x10
051B  00ED     MOVWF d
051C  01EE     CLRF 0x6E
927:                   r = freadM( NULL, d, fp);
051D  01D5     CLRF dest
051E  01D6     CLRF fp
051F  086E     MOVF 0x6E, W
0520  00D8     MOVWF 0x58
0521  086D     MOVF d, W
0522  00D7     MOVWF size
0523  086A     MOVF fp, W
0524  00D9     MOVWF fp
0525  318D     MOVLP 0xD
0526  25CE     CALL 0x5CE
0527  3185     MOVLP 0x5
0528  0856     MOVF fp, W
0529  00EC     MOVWF 0x6C
052A  0855     MOVF dest, W
052B  00EB     MOVWF r
928:                   count -= r;
052C  02E8     SUBWF lc, F
052D  086C     MOVF 0x6C, W
052E  3BE9     SUBWFB 0x69, F
929:                   if ( r != d)
052F  066E     XORWF 0x6E, W
0530  1D03     BTFSS STATUS, 0x2
0531  2D34     GOTO 0x534
0532  086D     MOVF d, W
0533  066B     XORWF r, W
0534  1D03     BTFSS STATUS, 0x2
0535  0008     RETURN
0536  2D0A     GOTO 0x50A
930:                       break;      // reached end of file or error
931:               } // while
932:           
933:               return count;
934:           } // fseekM
935:           
936:           
937:           
938:           //-------------------------------------------------------------
939:           // Scans the current disk and compiles a list of files 
940:           //   with a given extension
941:           //
942:           unsigned listTYPE( char *list, int max, const char *ext )
943:           // list     array of file names max * 8
944:           // max      number of entries
945:           // ext      file extension we are searching for
946:           // return   number of files found
947:           {
948:               unsigned eCount;        // current entry counter
949:               unsigned eOffs;         // current entry offset in buffer
950:               unsigned x, a, r;             
951:               MFILE *fp;
952:               unsigned char *b;
953:               
954:               x = 0;
955:               r = 0;
956:           
957:               // 1.  check if storage device is mounted 
958:               if ( D == NULL)         // unmounted
959:               {
960:                   FError = FE_MEDIA_NOT_MNTD;
961:                   return 0;
962:               }
963:               
964:               // 2. allocate a buffer for the file
965:               b = &B[D->cb];
966:               
967:               // 3. allocate a MFILE structure on the heap
968:               fp = &F[0];
969:               
970:               // 4. set pointers to the MEDIA structure and buffer
971:               fp->mda = D;
972:               fp->buffer = b;
973:           
974:               
975:               // 5. start from first entry, load first sector from root
976:               eCount = 0;
977:               eOffs = 0;
978:               if ( !ReadDIR( fp, eCount))
979:               {    //report error
980:                   FError = FE_FIND_ERROR;
981:                   goto ListExit;
982:               }
983:                       
984:               // 6. loop until you reach the end of the root directory
985:               while ( TRUE)
986:               {    
987:               // 6.1 read the first char of the file name 
988:                   a =  fp->buffer[ eOffs + DIR_NAME]; 
989:           
990:               // 6.2 terminate if it is empty (end of the list)        
991:                   if ( a == DIR_EMPTY)
992:                       break;
993:               // 6.3 
994:                   if ( a != DIR_DEL)
995:                   {
996:                     // if not hidden, print the file name and size
997:                     a = fp->buffer[ eOffs + DIR_ATTRIB];
998:                     if ( !( a & (ATT_HIDE|ATT_DIR))) 
999:                     {   //  check the file extension
1000:                      if ( !memcmp( &fp->buffer[ eOffs+DIR_EXT], ext, 3))
1001:                      {   
1002:                         // copy file name in playlist
1003:                         memcpy( &list[x*8], 
1004:                                 &fp->buffer[ eOffs+DIR_NAME], 8);
1005:                              
1006:                         // check if maximum number of entries reached
1007:                         if ( ++x >= max)
1008:                             break;
1009:                      }                        
1010:                    } // file
1011:                  } // not deleted or hidden
1012:                  
1013:              // 6.4 get the next entry
1014:              //     exit the loop if reached the end or error
1015:                  eCount++;
1016:                  if ( eCount > fp->mda->maxroot)
1017:                      break;              // last entry reached
1018:          
1019:                  eOffs += 32;
1020:                  if ( eOffs >= 512)
1021:                  { 
1022:                      eOffs = 0;
1023:                      if ( !ReadDIR( fp, eCount))
1024:                      {
1025:                          FError = FE_FIND_ERROR;
1026:                          goto ListExit;
1027:                      }
1028:                  }
1029:              }// while 
1030:              
1031:              // 7. return the number of files found
1032:              r = x;
1033:          
1034:          ListExit:
1035:              // 8. free buffers and return
1036:          //    free( fp->buffer);
1037:          //    free( fp);
1038:              return r;
1039:          
1040:          } // listTYPE
1041:          
1042:          
1043:          
1044:          //-------------------------------------------------------------
1045:          // Open Next File with given extension after last entry
1046:          //
1047:          MFILE *ffindM( const char *ext, unsigned *entry)
1048:          {
1049:              unsigned int eOffs;
1050:              char a;
1051:              MFILE *fp;
1052:          
1053:              // 1.  check if storage device is mounted
1054:              if ( D == NULL)       // unmounted
0A1E  0021     MOVLB 0x1
0A1F  085B     MOVF D, W
0A20  1D03     BTFSS 0x83, 0x2
0A21  2A25     GOTO 0x225
1055:              {
1056:                  FError = FE_MEDIA_NOT_MNTD;
0A22  3006     MOVLW 0x6
0A23  00DC     MOVWF FError
1057:                  return NULL;
0A24  3400     RETLW 0x0
1058:              }
1059:          
1060:              // 3. allocate a MFILE structure on the heap
1061:              fp = &F[0];
0A25  3020     MOVLW 0x20
0A26  0020     MOVLB 0x0
0A27  00D6     MOVWF fp
1062:          
1063:              // 4. set pointers to the MEDIA structure and buffer
1064:              fp->mda = D;
0A28  3E02     ADDLW 0x2
0A29  0086     MOVWF FSR1
0A2A  3001     MOVLW 0x1
0A2B  0087     MOVWF FSR1H
0A2C  0021     MOVLB 0x1
0A2D  085B     MOVF D, W
0A2E  0081     MOVWF 0x81
1065:              fp->buffer = &B[ D->cb];
0A2F  085B     MOVF D, W
0A30  0086     MOVWF 0x86
0A31  0801     MOVF 0x81, W
0A32  0020     MOVLB 0x0
0A33  00CB     MOVWF 0x4B
0A34  01CC     CLRF fp
0A35  00CC     MOVWF fp
0A36  30F0     MOVLW 0xF0
0A37  01CB     CLRF 0x4B
0A38  00CE     MOVWF 0x4E
0A39  3020     MOVLW 0x20
0A3A  00CF     MOVWF 0x4F
0A3B  084B     MOVF 0x4B, W
0A3C  074E     ADDWF 0x4E, W
0A3D  00D0     MOVWF 0x50
0A3E  084C     MOVF fp, W
0A3F  3D4F     ADDWFC 0x4F, W
0A40  00D1     MOVWF mda
0A41  0856     MOVF fp, W
0A42  0086     MOVWF FSR1
0A43  0850     MOVF 0x50, W
0A44  3FC0     MOVWI [0]FSR1
0A45  0851     MOVF mda, W
0A46  3FC1     MOVWI [1]FSR1
1066:          
1067:              // 5. start from given entry, load its sector from root
1068:              if ( !ReadDIR( fp, *entry))
0A47  084A     MOVF entry, W
0A48  0086     MOVWF FSR1
0A49  0187     CLRF FSR1H
0A4A  3F40     MOVIW [0]FSR1
0A4B  00B5     MOVWF e
0A4C  3F41     MOVIW [1]FSR1
0A4D  00B6     MOVWF 0x36
0A4E  0856     MOVF fp, W
0A4F  3184     MOVLP 0x4
0A50  246F     CALL 0x46F
0A51  3188     MOVLP 0x8
0A52  0835     MOVF e, W
0A53  0436     IORWF 0x36, W
0A54  1D03     BTFSS STATUS, 0x2
0A55  2BBD     GOTO 0x3BD
1069:              {    //report error
1070:                  FError = FE_FIND_ERROR;
0A56  3013     MOVLW 0x13
0A57  0021     MOVLB 0x1
0A58  00DC     MOVWF FError
1071:                  return NULL;
0A59  3400     RETLW 0x0
1072:              }
1073:          
1074:              // 6. loop until you reach a match or the end of the root directory
1075:              while ( *entry < fp->mda->maxroot)
0BBD  0856     MOVF 0xD6, W
0BBE  3E02     ADDLW 0x2
0BBF  0086     MOVWF 0x86
0BC0  3001     MOVLW 0x1
0BC1  0087     MOVWF 0x87
0BC2  0801     MOVF 0x81, W
0BC3  3E0D     ADDLW 0xD
0BC4  0086     MOVWF 0x86
0BC5  3F40     MOVIW [0]FSR1
0BC6  00CB     MOVWF 0xCB
0BC7  3F41     MOVIW [1]FSR1
0BC8  00CC     MOVWF 0xCC
0BC9  084A     MOVF 0xCA, W
0BCA  0086     MOVWF 0x86
0BCB  0187     CLRF 0x87
0BCC  3F40     MOVIW [0]FSR1
0BCD  00CD     MOVWF 0xCD
0BCE  3F41     MOVIW [1]FSR1
0BCF  00CE     MOVWF 0xCE
0BD0  084C     MOVF 0xCC, W
0BD1  024E     SUBWF 0xCE, W
0BD2  1D03     BTFSS 0x83, 0x2
0BD3  2BD6     GOTO 0x3D6
0BD4  084B     MOVF 0xCB, W
0BD5  024D     SUBWF 0xCD, W
0BD6  1803     BTFSC 0x83, 0x0
0BD8  2A5A     GOTO 0x25A
1076:              {
1077:                  eOffs = (*entry & 0xF) << 5;      // 32 bytes per entry
0A5A  084A     MOVF 0xCA, W
0A5B  0086     MOVWF 0x86
0A5C  0187     CLRF 0x87
0A5D  3F40     MOVIW [0]FSR1
0A5E  00D4     MOVWF fp
0A5F  3F41     MOVIW [1]FSR1
0A60  00D5     MOVWF entry
0A61  300F     MOVLW 0xF
0A62  05D4     ANDWF fp, F
0A63  3005     MOVLW 0x5
0A64  01D5     CLRF entry
0A65  35D4     LSLF fp, F
0A66  0DD5     RLF entry, F
0A67  0B89     DECFSZ 0x89, F
0A68  2A65     GOTO 0x265
1078:                  // 6.1 read the first char of the file name
1079:                  a =  fp->buffer[ eOffs + DIR_NAME];
0A69  0856     MOVF 0xD6, W
0A6A  0086     MOVWF 0x86
0A6B  3001     MOVLW 0x1
0A6C  0087     MOVWF 0x87
0A6D  3F40     MOVIW [0]FSR1
0A6E  00CB     MOVWF 0xCB
0A6F  3F41     MOVIW [1]FSR1
0A70  00CC     MOVWF 0xCC
0A71  0854     MOVF fp, W
0A72  074B     ADDWF 0xCB, W
0A73  0086     MOVWF 0x86
0A74  0855     MOVF entry, W
0A75  3D4C     ADDWFC 0xCC, W
0A76  0087     MOVWF 0x87
0A77  0801     MOVF 0x81, W
0A78  00D3     MOVWF 0xD3
1080:          
1081:                  // 6.2 terminate if it is empty (end of the list)
1082:                  if ( a == DIR_EMPTY)
0A79  0853     MOVF 0xD3, W
0A7A  1903     BTFSC 0x83, 0x2
0A7B  3400     RETLW 0x0
1083:                      break;
1084:          
1085:                  // 6.3 if not deleted entry to be skipped
1086:                  if ( a != DIR_DEL)
0A7C  30E5     MOVLW 0xE5
0A7D  0653     XORWF 0xD3, W
0A7E  1903     BTFSC 0x83, 0x2
0A7F  2BA8     GOTO 0x3A8
1087:                  {
1088:                    // if not hidden or directory name
1089:                    a = fp->buffer[ eOffs + DIR_ATTRIB];
0A80  0856     MOVF 0xD6, W
0A81  0086     MOVWF 0x86
0A82  3001     MOVLW 0x1
0A83  0087     MOVWF 0x87
0A84  3F40     MOVIW [0]FSR1
0A85  00CB     MOVWF 0xCB
0A86  3F41     MOVIW [1]FSR1
0A87  00CC     MOVWF 0xCC
0A88  0854     MOVF fp, W
0A89  074B     ADDWF 0xCB, W
0A8A  00CD     MOVWF 0xCD
0A8B  0855     MOVF entry, W
0A8C  3D4C     ADDWFC 0xCC, W
0A8D  00CE     MOVWF 0xCE
0A8E  084D     MOVF 0xCD, W
0A8F  0086     MOVWF 0x86
0A90  084E     MOVF 0xCE, W
0A91  0087     MOVWF 0x87
0A92  314B     ADDFSR 1, 11
0A93  0801     MOVF 0x81, W
0A94  00D3     MOVWF 0xD3
1090:                    if ( !( a & (ATT_HIDE|ATT_DIR)))
0A95  3912     ANDLW 0x12
0A96  1D03     BTFSS 0x83, 0x2
0A97  2BA8     GOTO 0x3A8
1091:                    {   //  check the file extension
1092:          
1093:                      // compare extension
1094:                      if ( !memcmp( &fp->buffer[ eOffs+DIR_EXT], ext, 3))
0A98  0856     MOVF 0xD6, W
0A99  0086     MOVWF 0x86
0A9A  3001     MOVLW 0x1
0A9B  0087     MOVWF 0x87
0A9C  3F40     MOVIW [0]FSR1
0A9D  00CB     MOVWF 0xCB
0A9E  3F41     MOVIW [1]FSR1
0A9F  00CC     MOVWF 0xCC
0AA0  0854     MOVF fp, W
0AA1  074B     ADDWF 0xCB, W
0AA2  00CD     MOVWF 0xCD
0AA3  0855     MOVF entry, W
0AA4  3D4C     ADDWFC 0xCC, W
0AA5  00CE     MOVWF 0xCE
0AA6  084D     MOVF 0xCD, W
0AA7  3E08     ADDLW 0x8
0AA8  00CF     MOVWF 0xCF
0AA9  3000     MOVLW 0x0
0AAA  3D4E     ADDWFC 0xCE, W
0AAB  00D0     MOVWF lc
0AAC  084F     MOVF 0xCF, W
0AAD  00A0     MOVWF __pcstackBANK1
0AAE  0850     MOVF lc, W
0AAF  00A1     MOVWF r
0AB0  0849     MOVF 0xC9, W
0AB1  00A3     MOVWF fp
0AB2  0848     MOVF 0xC8, W
0AB3  00A2     MOVWF 0xA2
0AB4  3003     MOVLW 0x3
0AB5  00A4     MOVWF 0xA4
0AB6  01A5     CLRF lc
0AB7  3184     MOVLP 0x4
0AB8  24D8     CALL 0x4D8
0AB9  3188     MOVLP 0x8
0ABA  0820     MOVF __pcstackBANK1, W
0ABB  0421     IORWF r, W
0ABC  1D03     BTFSS 0x83, 0x2
0ABD  2BA8     GOTO 0x3A8
1095:                      {
1096:                          // found it
1097:                          // 7. copy the file mode character  (r, w)
1098:                          fp->mode = 'r';
0ABE  0856     MOVF 0xD6, W
0ABF  3E24     ADDLW 0x24
0AC0  0086     MOVWF 0x86
0AC1  3001     MOVLW 0x1
0AC2  0087     MOVWF 0x87
0AC3  3072     MOVLW 0x72
0AC4  0081     MOVWF 0x81
1099:          
1100:                          // 8. entry found, fill the file structure
1101:                          fp->entry = *entry;         // store index
0AC5  084A     MOVF 0xCA, W
0AC6  0086     MOVWF 0x86
0AC7  0187     CLRF 0x87
0AC8  0856     MOVF 0xD6, W
0AC9  3E27     ADDLW 0x27
0ACA  0084     MOVWF 0x84
0ACB  3001     MOVLW 0x1
0ACC  0085     MOVWF 0x85
0ACD  3F40     MOVIW [0]FSR1
0ACE  3F80     MOVWI [0]FSR0
0ACF  3F41     MOVIW [1]FSR1
0AD0  3F81     MOVWI [1]FSR0
1102:                          fp->time    = ReadW( fp->buffer, eOffs+DIR_TIME);
0AD1  0856     MOVF 0xD6, W
0AD2  0086     MOVWF 0x86
0AD3  3001     MOVLW 0x1
0AD4  0087     MOVWF 0x87
0AD5  3F40     MOVIW [0]FSR1
0AD6  00CB     MOVWF 0xCB
0AD7  3F41     MOVIW [1]FSR1
0AD8  00CC     MOVWF 0xCC
0AD9  0854     MOVF fp, W
0ADA  074B     ADDWF 0xCB, W
0ADB  00CD     MOVWF 0xCD
0ADC  0855     MOVF entry, W
0ADD  3D4C     ADDWFC 0xCC, W
0ADE  00CE     MOVWF 0xCE
0ADF  084D     MOVF 0xCD, W
0AE0  0086     MOVWF 0x86
0AE1  084E     MOVF 0xCE, W
0AE2  0087     MOVWF 0x87
0AE3  3156     ADDFSR 1, 22
0AE4  0856     MOVF 0xD6, W
0AE5  3E15     ADDLW 0x15
0AE6  0084     MOVWF 0x84
0AE7  3001     MOVLW 0x1
0AE8  0085     MOVWF 0x85
0AE9  3F40     MOVIW [0]FSR1
0AEA  3F80     MOVWI [0]FSR0
0AEB  3F41     MOVIW [1]FSR1
0AEC  3F81     MOVWI [1]FSR0
1103:                          fp->date    = ReadW( fp->buffer, eOffs+DIR_DATE);
0AED  0856     MOVF 0xD6, W
0AEE  0086     MOVWF 0x86
0AEF  3001     MOVLW 0x1
0AF0  0087     MOVWF 0x87
0AF1  3F40     MOVIW [0]FSR1
0AF2  00CB     MOVWF 0xCB
0AF3  3F41     MOVIW [1]FSR1
0AF4  00CC     MOVWF 0xCC
0AF5  0854     MOVF fp, W
0AF6  074B     ADDWF 0xCB, W
0AF7  00CD     MOVWF 0xCD
0AF8  0855     MOVF entry, W
0AF9  3D4C     ADDWFC 0xCC, W
0AFA  00CE     MOVWF 0xCE
0AFB  084D     MOVF 0xCD, W
0AFC  0086     MOVWF 0x86
0AFD  084E     MOVF 0xCE, W
0AFE  0087     MOVWF 0x87
0AFF  3158     ADDFSR 1, 24
0B00  0856     MOVF 0xD6, W
0B01  3E17     ADDLW 0x17
0B02  0084     MOVWF 0x84
0B03  3001     MOVLW 0x1
0B04  0085     MOVWF 0x85
0B05  3F40     MOVIW [0]FSR1
0B06  3F80     MOVWI [0]FSR0
0B07  3F41     MOVIW [1]FSR1
0B08  3F81     MOVWI [1]FSR0
1104:                          fp->size    = ReadL( fp->buffer, eOffs+DIR_SIZE);
0B09  0856     MOVF 0xD6, W
0B0A  0086     MOVWF 0x86
0B0B  3001     MOVLW 0x1
0B0C  0087     MOVWF 0x87
0B0D  3F40     MOVIW [0]FSR1
0B0E  00CB     MOVWF 0xCB
0B0F  3F41     MOVIW [1]FSR1
0B10  00CC     MOVWF 0xCC
0B11  0854     MOVF fp, W
0B12  074B     ADDWF 0xCB, W
0B13  00CD     MOVWF 0xCD
0B14  0855     MOVF entry, W
0B15  3D4C     ADDWFC 0xCC, W
0B16  00CE     MOVWF 0xCE
0B17  084D     MOVF 0xCD, W
0B18  0086     MOVWF 0x86
0B19  084E     MOVF 0xCE, W
0B1A  0087     MOVWF 0x87
0B1B  315C     ADDFSR 1, 28
0B1C  3F40     MOVIW [0]FSR1
0B1D  00CF     MOVWF 0xCF
0B1E  3F41     MOVIW [1]FSR1
0B1F  00D0     MOVWF lc
0B20  3F42     MOVIW [2]FSR1
0B21  00D1     MOVWF 0xD1
0B22  3F43     MOVIW [3]FSR1
0B23  00D2     MOVWF 0xD2
0B24  0856     MOVF 0xD6, W
0B25  3E11     ADDLW 0x11
0B26  0086     MOVWF 0x86
0B27  3001     MOVLW 0x1
0B28  0087     MOVWF 0x87
0B29  084F     MOVF 0xCF, W
0B2A  3FC0     MOVWI [0]FSR1
0B2B  0850     MOVF lc, W
0B2C  3FC1     MOVWI [1]FSR1
0B2D  0851     MOVF 0xD1, W
0B2E  3FC2     MOVWI [2]FSR1
0B2F  0852     MOVF 0xD2, W
0B30  3FC3     MOVWI [3]FSR1
1105:                          fp->cluster = ReadL( fp->buffer, eOffs+DIR_CLST);
0B31  0856     MOVF 0xD6, W
0B32  0086     MOVWF 0x86
0B33  3F40     MOVIW [0]FSR1
0B34  00CB     MOVWF 0xCB
0B35  3F41     MOVIW [1]FSR1
0B36  00CC     MOVWF 0xCC
0B37  0854     MOVF fp, W
0B38  074B     ADDWF 0xCB, W
0B39  00CD     MOVWF 0xCD
0B3A  0855     MOVF entry, W
0B3B  3D4C     ADDWFC 0xCC, W
0B3C  00CE     MOVWF 0xCE
0B3D  084D     MOVF 0xCD, W
0B3E  0086     MOVWF 0x86
0B3F  084E     MOVF 0xCE, W
0B40  0087     MOVWF 0x87
0B41  315A     ADDFSR 1, 26
0B42  0856     MOVF 0xD6, W
0B43  3E03     ADDLW 0x3
0B44  0084     MOVWF 0x84
0B45  3001     MOVLW 0x1
0B46  0085     MOVWF 0x85
0B47  3F40     MOVIW [0]FSR1
0B48  3F80     MOVWI [0]FSR0
0B49  3F41     MOVIW [1]FSR1
0B4A  3F81     MOVWI [1]FSR0
1106:          
1107:                          // 9. init all counters to the beginning of the file
1108:                          fp->seek = 0;               // first byte in file
0B4B  0856     MOVF 0xD6, W
0B4C  3E0D     ADDLW 0xD
0B4D  0086     MOVWF 0x86
0B4E  3001     MOVLW 0x1
0B4F  0087     MOVWF 0x87
0B50  3000     MOVLW 0x0
0B51  3FC0     MOVWI [0]FSR1
0B52  3FC1     MOVWI [1]FSR1
0B53  3FC2     MOVWI [2]FSR1
0B54  3FC3     MOVWI [3]FSR1
1109:                          fp->sec = 0;                // first sector in the cluster
0B55  0856     MOVF 0xD6, W
0B56  3E07     ADDLW 0x7
0B57  0086     MOVWF 0x86
0B58  3000     MOVLW 0x0
0B59  3FC0     MOVWI [0]FSR1
0B5A  3FC1     MOVWI [1]FSR1
1110:                          fp->pos = 0;                // first byte in sector/cluster
0B5B  0856     MOVF 0xD6, W
0B5C  3E09     ADDLW 0x9
0B5D  0086     MOVWF 0x86
0B5E  3000     MOVLW 0x0
0B5F  3FC0     MOVWI [0]FSR1
0B60  3FC1     MOVWI [1]FSR1
1111:          
1112:                          // 10. set current cluster pointer on first cluster
1113:                          fp->ccls = fp->cluster;
0B61  0856     MOVF 0xD6, W
0B62  3E03     ADDLW 0x3
0B63  0086     MOVWF 0x86
0B64  0856     MOVF 0xD6, W
0B65  3E05     ADDLW 0x5
0B66  0084     MOVWF 0x84
0B67  3F40     MOVIW [0]FSR1
0B68  3F80     MOVWI [0]FSR0
0B69  3F41     MOVIW [1]FSR1
0B6A  3F81     MOVWI [1]FSR0
1114:          
1115:                          // 11. read a sector of data from the file
1116:                          if ( !ReadDATA( fp))
0B6B  0856     MOVF 0xD6, W
0B6C  2753     CALL 0x753
0B6D  3188     MOVLP 0x8
0B6E  0835     MOVF 0xB5, W
0B6F  0436     IORWF 0xB6, W
0B70  1903     BTFSC 0x83, 0x2
0B71  2A56     GOTO 0x256
1117:                          {
1118:                              FError = FE_FIND_ERROR;
1119:                              return NULL;
1120:                          }
1121:          
1122:                          // 12. determine how much data is really inside the buffer
1123:                          if ( fp->size < 512)
0B72  0856     MOVF 0xD6, W
0B73  3E11     ADDLW 0x11
0B74  0086     MOVWF 0x86
0B75  3001     MOVLW 0x1
0B76  0087     MOVWF 0x87
0B77  3F43     MOVIW [3]FSR1
0B78  1B89     BTFSC 0x89, 0x7
0B79  2B86     GOTO 0x386
0B7A  3F43     MOVIW [3]FSR1
0B7B  1D03     BTFSS 0x83, 0x2
0B7C  2B95     GOTO 0x395
0B7D  3F42     MOVIW [2]FSR1
0B7E  1D03     BTFSS 0x83, 0x2
0B7F  2B95     GOTO 0x395
0B80  3F41     MOVIW [1]FSR1
0B81  00CB     MOVWF 0xCB
0B82  3002     MOVLW 0x2
0B83  024B     SUBWF 0xCB, W
0B84  1803     BTFSC 0x83, 0x0
0B85  2B95     GOTO 0x395
1124:                              fp->top = fp->size;
0B86  0856     MOVF 0xD6, W
0B87  3E11     ADDLW 0x11
0B88  0086     MOVWF 0x86
0B89  3001     MOVLW 0x1
0B8A  0087     MOVWF 0x87
0B8B  0856     MOVF 0xD6, W
0B8C  3E0B     ADDLW 0xB
0B8D  0084     MOVWF 0x84
0B8E  3001     MOVLW 0x1
0B8F  0085     MOVWF 0x85
0B90  3F40     MOVIW [0]FSR1
0B91  3F80     MOVWI [0]FSR0
0B92  3F41     MOVIW [1]FSR1
0B93  3F81     MOVWI [1]FSR0
0B94  2B9E     GOTO 0x39E
1125:                          else
1126:                              fp->top = 512;
0B95  0856     MOVF 0xD6, W
0B96  3E0B     ADDLW 0xB
0B97  0086     MOVWF 0x86
0B98  3001     MOVLW 0x1
0B99  0087     MOVWF 0x87
0B9A  3000     MOVLW 0x0
0B9B  3FC0     MOVWI [0]FSR1
0B9C  3002     MOVLW 0x2
0B9D  3FC1     MOVWI [1]FSR1
1127:          
1128:                          // success
1129:                          (*entry)++;
0B9E  084A     MOVF 0xCA, W
0B9F  0086     MOVWF 0x86
0BA0  3001     MOVLW 0x1
0BA1  0187     CLRF 0x87
0BA2  0781     ADDWF 0x81, F
0BA3  3141     ADDFSR 1, 1
0BA4  1803     BTFSC 0x83, 0x0
0BA5  0A81     INCF 0x81, F
1130:                          return fp;
0BA6  0856     MOVF 0xD6, W
0BA7  0008     RETURN
1131:                      }
1132:                    } // it's a file
1133:                  } // it's not deleted or hidden
1134:          
1135:                  // 13. get the next entry
1136:                  (*entry)++;
0BA8  084A     MOVF 0xCA, W
0BA9  0086     MOVWF 0x86
0BAA  3001     MOVLW 0x1
0BAB  0187     CLRF 0x87
0BAC  0781     ADDWF 0x81, F
0BAD  3141     ADDFSR 1, 1
0BAE  1803     BTFSC 0x83, 0x0
0BAF  0A81     INCF 0x81, F
1137:          
1138:                  if (( *entry & 0xF) == 0)
0BB0  084A     MOVF 0xCA, W
0BB1  0086     MOVWF 0x86
0BB2  0187     CLRF 0x87
0BB3  0801     MOVF 0x81, W
0BB4  390F     ANDLW 0xF
0BB5  1D03     BTFSS 0x83, 0x2
0BB6  2BBD     GOTO 0x3BD
1139:                  {
1140:                      if ( !ReadDIR( fp, *entry))
0BB7  084A     MOVF 0xCA, W
0BB8  0086     MOVWF 0x86
0BB9  3F40     MOVIW [0]FSR1
0BBA  00B5     MOVWF 0xB5
0BBB  3F41     MOVIW [1]FSR1
0BBC  2A4D     GOTO 0x24D
1141:                      {
1142:                          FError = FE_FIND_ERROR;
1143:                          return NULL;
1144:                      }
1145:                  }
1146:              }// while
1147:          
1148:              // 14. finished without finding it
1149:              return NULL;
0BD7  3400     RETLW 0x0
0BD8  2A5A     GOTO 0x25A
1150:          
1151:          } // ffindM
---  /Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/Wave.c  -------------
1:             /*
2:             ** Wave.C
3:             ** 
4:             **  Wave File Player 
5:             **  Modified for operation at <22050 Hz (8-bit mono)
6:             */
7:             
8:             #include <xc.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include "AudioDAC.h"
12:            #include "SDMMC.h"
13:            #include "fileio.h"
14:            #include "MCC_Generated_Files/mcc.h"
15:            
16:            
17:            // WAVE file constants
18:            #define  RIFF_DWORD  0x46464952UL
19:            #define  WAVE_DWORD  0x45564157UL
20:            #define  DATA_DWORD  0x61746164UL
21:            #define  FMT_DWORD   0x20746d66UL     
22:            #define  WAV_DWORD   0x00564157UL
23:            
24:            
25:            typedef struct {
26:                long ckID;
27:                long ckSize;
28:                long ckType;
29:            } chunk;
30:            
31:            typedef struct {
32:                // format chunk 
33:                unsigned short  subtype;    // compression code  
34:                unsigned short  channels;   // # of channels
35:                                            //  (1= mono,2= stereo)
36:                unsigned long   srate;      // sample rate in Hz
37:                unsigned long   bps;        // bytes per second
38:                unsigned short  align;      // block alignement
39:                unsigned short  bitpsample; // bit per sample
40:            //    unsigned short  extra;      // extra format bytes
41:            } WAVE_fmt;
42:            
43:            
44:            unsigned long InitWAV( MFILE * fp)
0CE6  00C0     MOVWF fp
45:            {
46:                chunk       ck;
47:                WAVE_fmt    wav;
48:                unsigned long lc;
49:            
50:                // audio codec parameters
51:                unsigned char skip, size, stereo;
52:                unsigned long rate;
53:                
54:                // 2. verify it is a RIFF-WAVE formatted file
55:                freadM( (void*)&ck, sizeof(chunk), fp);
0CE7  30C1     MOVLW 0xC1
0CE8  0020     MOVLB 0x0
0CE9  00D5     MOVWF dest
0CEA  3000     MOVLW 0x0
0CEB  00D6     MOVWF fp
0CEC  300C     MOVLW 0xC
0CED  00D7     MOVWF size
0CEE  01D8     CLRF 0x58
0CEF  0021     MOVLB 0x1
0CF0  0840     MOVF fp, W
0CF1  0020     MOVLB 0x0
0CF2  00D9     MOVWF fp
0CF3  25CE     CALL 0x5CE
0CF4  3188     MOVLP 0x8
56:                   
57:                // check that file type is correct
58:                if (( ck.ckID != RIFF_DWORD) || ( ck.ckType != WAVE_DWORD))
0CF5  3052     MOVLW 0x52
0CF6  0021     MOVLB 0x1
0CF7  0641     XORWF ck, W
0CF8  3049     MOVLW 0x49
0CF9  1903     BTFSC 0x83, 0x2
0CFA  0642     XORWF 0xC2, W
0CFB  3046     MOVLW 0x46
0CFC  1903     BTFSC 0x83, 0x2
0CFD  0643     XORWF 0xC3, W
0CFE  3046     MOVLW 0x46
0CFF  1903     BTFSC 0x83, 0x2
0D00  0644     XORWF 0xC4, W
0D01  1D03     BTFSS 0x83, 0x2
0D02  2DCC     GOTO 0x5CC
0D03  3057     MOVLW 0x57
0D04  0649     XORWF 0xC9, W
0D05  3041     MOVLW 0x41
0D06  1903     BTFSC 0x83, 0x2
0D07  064A     XORWF 0xCA, W
0D08  3056     MOVLW 0x56
0D09  1903     BTFSC 0x83, 0x2
0D0A  064B     XORWF 0xCB, W
0D0B  3045     MOVLW 0x45
0D0C  1903     BTFSC 0x83, 0x2
0D0D  064C     XORWF 0xCC, W
0D0E  1D03     BTFSS 0x83, 0x2
0D0F  2DCC     GOTO 0x5CC
59:                    goto Exit;
60:                    
61:                // 3. look for the chunk containing the wave format data
62:                freadM( (void*)&ck, 8, fp);
0D10  30C1     MOVLW 0xC1
0D11  0020     MOVLB 0x0
0D12  00D5     MOVWF dest
0D13  3000     MOVLW 0x0
0D14  00D6     MOVWF fp
0D15  3008     MOVLW 0x8
0D16  00D7     MOVWF size
0D17  01D8     CLRF 0x58
0D18  0021     MOVLB 0x1
0D19  0840     MOVF fp, W
0D1A  0020     MOVLB 0x0
0D1B  00D9     MOVWF fp
0D1C  25CE     CALL 0x5CE
0D1D  3188     MOVLP 0x8
63:                if ( ck.ckID != FMT_DWORD)
0D1E  3066     MOVLW 0x66
0D1F  0021     MOVLB 0x1
0D20  0641     XORWF ck, W
0D21  306D     MOVLW 0x6D
0D22  1903     BTFSC 0x83, 0x2
0D23  0642     XORWF 0xC2, W
0D24  3074     MOVLW 0x74
0D25  1903     BTFSC 0x83, 0x2
0D26  0643     XORWF 0xC3, W
0D27  3020     MOVLW 0x20
0D28  1903     BTFSC 0x83, 0x2
0D29  0644     XORWF 0xC4, W
0D2A  1D03     BTFSS 0x83, 0x2
0D2B  2DCC     GOTO 0x5CC
64:                    goto Exit;
65:            
66:                // 4. get the WAVE_FMT struct
67:                freadM( (void*)&wav, sizeof(WAVE_fmt), fp);
0D2C  30B0     MOVLW 0xB0
0D2D  0020     MOVLB 0x0
0D2E  00D5     MOVWF dest
0D2F  3000     MOVLW 0x0
0D30  00D6     MOVWF fp
0D31  3010     MOVLW 0x10
0D32  00D7     MOVWF size
0D33  01D8     CLRF 0x58
0D34  0021     MOVLB 0x1
0D35  0840     MOVF fp, W
0D36  0020     MOVLB 0x0
0D37  00D9     MOVWF fp
0D38  25CE     CALL 0x5CE
68:                stereo = wav.channels;
69:                 
70:                // 5. skip extra format bytes
71:                fseekM( fp, ck.ckSize - sizeof(WAVE_fmt));
0D39  0021     MOVLB 0x1
0D3A  0846     MOVF 0xC6, W
0D3B  0020     MOVLB 0x0
0D3C  00E9     MOVWF 0x69
0D3D  0021     MOVLB 0x1
0D3E  0845     MOVF 0xC5, W
0D3F  0020     MOVLB 0x0
0D40  00E8     MOVWF lc
0D41  30F0     MOVLW 0xF0
0D42  07E8     ADDWF lc, F
0D43  30FF     MOVLW 0xFF
0D44  3DE9     ADDWFC 0x69, F
0D45  0021     MOVLB 0x1
0D46  0840     MOVF fp, W
0D47  3185     MOVLP 0x5
0D48  2508     CALL 0x508
0D49  3188     MOVLP 0x8
72:                     
73:                // 6. search for the "data" chunk
74:                while( 1)
75:                {   // read next chunk 
76:                    if ( freadM( (void*)&ck, 8, fp) != 8)
0D4A  30C1     MOVLW 0xC1
0D4B  00D5     MOVWF entry
0D4C  3000     MOVLW 0x0
0D4D  00D6     MOVWF 0xD6
0D4E  3008     MOVLW 0x8
0D4F  00D7     MOVWF BPtr
0D50  01D8     CLRF 0xD8
0D51  0021     MOVLB 0x1
0D52  0840     MOVF fp, W
0D53  0020     MOVLB 0x0
0D54  00D9     MOVWF fp
0D55  25CE     CALL 0x5CE
0D56  3188     MOVLP 0x8
0D57  3008     MOVLW 0x8
0D58  0655     XORWF dest, W
0D59  0456     IORWF fp, W
0D5A  1D03     BTFSS STATUS, 0x2
0D5B  2DCC     GOTO 0x5CC
77:                        goto Exit;
78:            
79:                    if ( ck.ckID != DATA_DWORD)
0D5C  3064     MOVLW 0x64
0D5D  0021     MOVLB 0x1
0D5E  0641     XORWF ck, W
0D5F  3061     MOVLW 0x61
0D60  1903     BTFSC 0x83, 0x2
0D61  0642     XORWF 0xC2, W
0D62  3074     MOVLW 0x74
0D63  1903     BTFSC 0x83, 0x2
0D64  0643     XORWF 0xC3, W
0D65  3061     MOVLW 0x61
0D66  1903     BTFSC 0x83, 0x2
0D67  0644     XORWF 0xC4, W
0D68  1903     BTFSC 0x83, 0x2
0D69  2D72     GOTO 0x572
80:                        fseekM( fp, ck.ckSize );
0D6A  0846     MOVF 0xC6, W
0D6B  0020     MOVLB 0x0
0D6C  00E9     MOVWF 0x69
0D6D  0021     MOVLB 0x1
0D6E  0845     MOVF 0xC5, W
0D6F  0020     MOVLB 0x0
0D70  00E8     MOVWF lc
0D71  2D45     GOTO 0x545
81:                    else
82:                        break;
83:                } 
84:            
85:                // 7. find the data size 
86:                lc = ck.ckSize;
0D72  30C5     MOVLW 0xC5
0D73  0086     MOVWF FSR1
0D74  0187     CLRF FSR1H
0D75  3F40     MOVIW [0]FSR1
0D76  00A5     MOVWF 0x25
0D77  3F41     MOVIW [1]FSR1
0D78  00A6     MOVWF a
0D79  3F42     MOVIW [2]FSR1
0D7A  00A7     MOVWF 0x27
0D7B  3F43     MOVIW [3]FSR1
0D7C  00A8     MOVWF 0x28
87:            
88:                // 8. compute the period and adjust the bit rate
89:                rate = wav.srate;          // r = samples per second
0D7D  3004     MOVLW 0x4
0D7E  3EB0     ADDLW 0xB0
0D7F  0086     MOVWF FSR1
0D80  3F40     MOVIW [0]FSR1
0D81  00AC     MOVWF flag
0D82  3F41     MOVIW [1]FSR1
0D83  00AD     MOVWF idx
0D84  3F42     MOVIW [2]FSR1
0D85  00AE     MOVWF val
0D86  3F43     MOVIW [3]FSR1
0D87  00AF     MOVWF 0x2F
90:                skip = 1;                  // skip factor to reduce noise
0D88  01A9     CLRF r
0D89  0AA9     INCF r, F
91:                while ( rate < 44100)
0D8A  082F     MOVF 0x2F, W
0D8B  1D03     BTFSS STATUS, 0x2
0D8C  2D9C     GOTO 0x59C
0D8D  082E     MOVF val, W
0D8E  1D03     BTFSS STATUS, 0x2
0D8F  2D9C     GOTO 0x59C
0D90  3044     MOVLW 0x44
0D91  022C     SUBWF flag, W
0D92  30AC     MOVLW 0xAC
0D93  3B2D     SUBWFB idx, W
0D94  1803     BTFSC STATUS, 0x0
0D95  2D9C     GOTO 0x59C
0D9B  2D8A     GOTO 0x58A
92:                {
93:                    rate <<= 1;            // divide sample rate by two
0D96  35AC     LSLF flag, F
0D97  0DAD     RLF idx, F
0D98  0DAE     RLF val, F
0D99  0DAF     RLF 0x2F, F
94:                    skip <<= 1;            // multiply skip by two
0D9A  35A9     LSLF r, F
95:                }
96:            
97:                // 9. check if the sample rate compatible 
98:                if ( rate > 44100)
0D9C  082F     MOVF 0x2F, W
0D9D  1D03     BTFSS STATUS, 0x2
0D9E  2DA8     GOTO 0x5A8
0D9F  082E     MOVF val, W
0DA0  1D03     BTFSS STATUS, 0x2
0DA1  2DA8     GOTO 0x5A8
0DA2  3045     MOVLW 0x45
0DA3  022C     SUBWF flag, W
0DA4  30AC     MOVLW 0xAC
0DA5  3B2D     SUBWFB idx, W
0DA6  1C03     BTFSS STATUS, 0x0
0DA7  2DAF     GOTO 0x5AF
99:                {
100:                   fcloseM( fp);
0DA8  0840     MOVF 0x40, W
0DA9  27C1     CALL 0x7C1
101:                   return FALSE;
0DAA  01A0     CLRF __pcstackBANK0
0DAB  01A1     CLRF quotient
0DAC  01A2     CLRF s2
0DAD  01A3     CLRF f
0DAE  0008     RETURN
102:               }
103:               
104:               // 10. init the Audio state machine
105:               CurBuf = 0;
0DAF  01F8     CLRF CurBuf
106:               stereo = wav.channels;
0DB0  0832     MOVF c, W
0DB1  00AB     MOVWF i
107:               size  = 1;                  // default, bytes per channel
0DB3  01AA     CLRF p
0DB4  0AAA     INCF p, F
108:               if ( wav.bitpsample == 16)
0DB2  3010     MOVLW 0x10
0DB5  063E     XORWF 0x3E, W
0DB6  043F     IORWF psize, W
0DB7  1D03     BTFSS STATUS, 0x2
0DB8  2DBB     GOTO 0x5BB
109:                   size = 2;
0DB9  3002     MOVLW 0x2
0DBA  00AA     MOVWF p
110:               
111:               // 11. init the audio state machine
112:               InitAudio( skip, size, stereo);
0DBB  082A     MOVF p, W
0DBC  00F3     MOVWF state
0DBD  082B     MOVF i, W
0DBE  00F4     MOVWF stereo
0DBF  0829     MOVF r, W
0DC0  3185     MOVLP 0x5
0DC1  255C     CALL 0x55C
113:           
114:               // return the file length
115:               return lc;
0DC2  0021     MOVLB 0x1
0DC3  0828     MOVF 0xA8, W
0DC4  00A3     MOVWF fp
0DC5  0827     MOVF 0xA7, W
0DC6  00A2     MOVWF 0xA2
0DC7  0826     MOVF 0xA6, W
0DC8  00A1     MOVWF r
0DC9  0825     MOVF lc, W
0DCA  00A0     MOVWF __pcstackBANK1
0DCB  0008     RETURN
116:           
117:               Exit:
118:           
119:               // 17. close the file
120:               fcloseM( fp);
0DCC  0021     MOVLB 0x1
0DCD  2DA8     GOTO 0x5A8
121:           
122:               return 0;
123:           }
124:           
125:           
126:           void Play( MFILE *fp, unsigned long lc)
0BD9  00A3     MOVWF fp
127:           {
128:               unsigned r;
129:               unsigned char      last;
130:           
131:               // 1. start loading both buffers
132:               if ( lc < B_SIZE*2)         // allow for files > BSIZE*2
0BDA  0020     MOVLB 0x0
0BDB  086B     MOVF r, W
0BDC  1D03     BTFSS STATUS, 0x2
0BDD  2BE5     GOTO 0x3E5
0BDE  086A     MOVF fp, W
0BDF  1D03     BTFSS STATUS, 0x2
0BE0  2BE5     GOTO 0x3E5
0BE1  3002     MOVLW 0x2
0BE2  0269     SUBWF 0x69, W
0BE3  1C03     BTFSS STATUS, 0x0
0BE4  0008     RETURN
133:                   return;
134:           
135:               // 1.b skip to the beginning of the next complete sector
136:               fp->pos = fp->top;              // effectively consider the rest as read
0BE5  0021     MOVLB 0x1
0BE6  0823     MOVF fp, W
0BE7  3E0B     ADDLW 0xB
0BE8  0086     MOVWF 0x86
0BE9  3001     MOVLW 0x1
0BEA  0087     MOVWF 0x87
0BEB  0823     MOVF fp, W
0BEC  3E09     ADDLW 0x9
0BED  0084     MOVWF 0x84
0BEE  3001     MOVLW 0x1
0BEF  0085     MOVWF 0x85
0BF0  3F40     MOVIW [0]FSR1
0BF1  3F80     MOVWI [0]FSR0
0BF2  3F41     MOVIW [1]FSR1
0BF3  3F81     MOVWI [1]FSR0
137:           
138:               // now the next read will cause an entire sector to be read in
139:               D->cb = 1;                      // move onto the second buffer
0BF4  085B     MOVF D, W
0BF5  0086     MOVWF 0x86
0BF7  0181     CLRF 0x81
0BF8  0A81     INCF 0x81, F
140:               r = freadM( B[0], B_SIZE, fp);  // fill buffer 0<-1 and 2 with first sector
0BF6  30F0     MOVLW 0xF0
0BF9  0020     MOVLB 0x0
0BFA  00D5     MOVWF dest
0BFB  3020     MOVLW 0x20
0BFC  00D6     MOVWF fp
0BFD  3001     MOVLW 0x1
0BFE  01D7     CLRF size
0BFF  00D8     MOVWF 0x58
0C00  0021     MOVLB 0x1
0C01  0823     MOVF fp, W
0C02  0020     MOVLB 0x0
0C03  00D9     MOVWF fp
0C04  25CE     CALL 0x5CE
0C05  3188     MOVLP 0x8
141:               fp->pos = fp->top;              // effectively consider the rest as read
0C06  0021     MOVLB 0x1
0C07  0823     MOVF fp, W
0C08  3E0B     ADDLW 0xB
0C09  0086     MOVWF 0x86
0C0A  3001     MOVLW 0x1
0C0B  0087     MOVWF 0x87
0C0C  0823     MOVF fp, W
0C0D  3E09     ADDLW 0x9
0C0E  0084     MOVWF 0x84
0C0F  3001     MOVLW 0x1
0C10  0085     MOVWF 0x85
0C11  3F40     MOVIW [0]FSR1
0C12  3F80     MOVWI [0]FSR0
0C13  3F41     MOVIW [1]FSR1
0C14  3F81     MOVWI [1]FSR0
142:           
143:               D->cb = 0;                      // make buffer 0,1 active
0C15  085B     MOVF D, W
0C16  0086     MOVWF 0x86
0C17  0181     CLRF 0x81
144:               CurBuf = 0;                     // play from 0
0C18  01F8     CLRF 0xF8
145:           
146:               AEmptyFlag = FALSE;         // both buffers are full
0C19  01D9     CLRF AEmptyFlag
147:               lc-= B_SIZE*2 ;             // keep track of what is left
0C1A  3000     MOVLW 0x0
0C1B  0020     MOVLB 0x0
0C1C  02E8     SUBWF lc, F
0C1D  3002     MOVLW 0x2
0C1E  3BE9     SUBWFB 0x69, F
0C1F  3000     MOVLW 0x0
0C20  3BEA     SUBWFB fp, F
0C21  3BEB     SUBWFB r, F
148:           
149:               // 2. start the audio
150:               StartAudio();
0C22  27E8     CALL 0x7E8
0C23  3188     MOVLP 0x8
151:           
152:               // 3. keep feeding the buffers in the playing loop
153:               while (lc >= 2* B_SIZE)
0C24  2C5B     GOTO 0x45B
0C5B  0020     MOVLB 0x0
0C5C  086B     MOVF r, W
0C5D  1D03     BTFSS STATUS, 0x2
0C5E  2C66     GOTO 0x466
0C5F  086A     MOVF fp, W
0C60  1D03     BTFSS STATUS, 0x2
0C61  2C66     GOTO 0x466
0C62  3002     MOVLW 0x2
0C63  0269     SUBWF 0x69, W
0C64  1C03     BTFSS STATUS, 0x0
0C65  2C6C     GOTO 0x46C
154:               {
155:                   if ( SW1_GetValue() == 0) // on pressing the button-> abort
0C66  1A8C     BTFSC PORTA, 0x5
0C67  2C25     GOTO 0x425
156:                   {
157:                       lc = 0;               // signal playback completed
0C68  01E8     CLRF lc
0C69  01E9     CLRF 0x69
0C6A  01EA     CLRF fp
0C6B  01EB     CLRF r
158:                       break;
159:                   }
160:                   
161:                   if ( AEmptyFlag)
0C25  0021     MOVLB 0x1
0C26  0859     MOVF AEmptyFlag, W
0C27  1903     BTFSC 0x83, 0x2
0C28  2C5B     GOTO 0x45B
162:                   {
163:                       if ( CurBuf)             // if buffer 2 is in use
0C29  0878     MOVF 0xF8, W
0C2A  1903     BTFSC 0x83, 0x2
0C2B  2C43     GOTO 0x443
164:                       {
165:           //            LED3_LAT = 1;
166:                           r = freadM( NULL, 2*B_SIZE, fp);  // read the next sector
0C2C  0020     MOVLB 0x0
0C2D  3002     MOVLW 0x2
0C2E  01D5     CLRF dest
0C2F  01D6     CLRF fp
0C30  01D7     CLRF size
0C31  00D8     MOVWF 0x58
0C32  0021     MOVLB 0x1
0C33  0823     MOVF fp, W
0C34  0020     MOVLB 0x0
0C35  00D9     MOVWF fp
0C36  25CE     CALL 0x5CE
0C37  3188     MOVLP 0x8
167:                           lc-= 2*B_SIZE;
0C38  3000     MOVLW 0x0
0C39  02E8     SUBWF lc, F
0C3A  3002     MOVLW 0x2
0C3B  3BE9     SUBWFB 0x69, F
0C3C  3000     MOVLW 0x0
0C3D  3BEA     SUBWFB fp, F
0C3E  3BEB     SUBWFB r, F
168:                           putch('.');
0C3F  302E     MOVLW 0x2E
0C40  2182     CALL 0x182
0C41  3188     MOVLP 0x8
169:           //            LED3_LAT = 0;
170:                       }
0C42  2C59     GOTO 0x459
171:                       else                    // buffer 0 is in use
172:                       {
173:                           memcpy( B[2], B[1], B_SIZE);
0C43  30F0     MOVLW 0xF0
0C44  0086     MOVWF FSR1
0C45  3022     MOVLW 0x22
0C46  0087     MOVWF FSR1H
0C47  30F0     MOVLW 0xF0
0C48  0084     MOVWF FSR0
0C49  3021     MOVLW 0x21
0C4A  0085     MOVWF FSR0H
0C4B  0020     MOVLB 0x0
0C4C  3001     MOVLW 0x1
0C4D  01EC     CLRF 0x6C
0C4E  00ED     MOVWF d
0C4F  0012     MOVIW FSR0++
0C50  001E     MOVWI FSR1++
0C51  3001     MOVLW 0x1
0C52  02EC     SUBWF 0x6C, F
0C53  3000     MOVLW 0x0
0C54  3BED     SUBWFB d, F
0C55  086D     MOVF d, W
0C56  046C     IORWF 0x6C, W
0C57  1D03     BTFSS STATUS, 0x2
0C58  2C4F     GOTO 0x44F
174:                       }
175:                       AEmptyFlag = FALSE;
0C59  0021     MOVLB 0x1
0C5A  01D9     CLRF AEmptyFlag
176:                       
177:                   }
178:               } // while wav data available
179:           
180:               // 14. flush the buffers with the data tail
181:               if( lc>0) 
0C6C  086B     MOVF 0xEB, W
0C6D  046A     IORWF 0xEA, W
0C6E  0469     IORWF 0xE9, W
0C6F  0468     IORWF 0xE8, W
0C70  1903     BTFSC 0x83, 0x2
0C71  2CDC     GOTO 0x4DC
182:               {
183:                   if ( AEmptyFlag)
0C72  0021     MOVLB 0x1
0C73  0859     MOVF AEmptyFlag, W
0C74  1903     BTFSC 0x83, 0x2
0C75  2CDC     GOTO 0x4DC
184:                   {
185:                       if ( CurBuf)             // if buffer 2 is in use
0C76  0878     MOVF 0xF8, W
0C77  1903     BTFSC 0x83, 0x2
0C78  2CC0     GOTO 0x4C0
186:                       {
187:           //            LED3_LAT = 1;
188:                           r = freadM( NULL, lc, fp);  // read the next sector
0C79  0020     MOVLB 0x0
0C7A  01D5     CLRF dest
0C7B  01D6     CLRF fp
0C7C  0869     MOVF 0x69, W
0C7D  00D8     MOVWF 0x58
0C7E  0868     MOVF lc, W
0C7F  00D7     MOVWF size
0C80  0021     MOVLB 0x1
0C81  0823     MOVF fp, W
0C82  0020     MOVLB 0x0
0C83  00D9     MOVWF fp
0C84  25CE     CALL 0x5CE
0C85  3188     MOVLP 0x8
0C86  0856     MOVF fp, W
0C87  0021     MOVLB 0x1
0C88  00A2     MOVWF 0xA2
0C89  0020     MOVLB 0x0
0C8A  0855     MOVF dest, W
0C8B  0021     MOVLB 0x1
0C8C  00A1     MOVWF r
189:                           lc=0;
190:                           // fill ther rest of the last buffer
191:                           last = B[0][r-1];       // get hte last value
0C8D  30EF     MOVLW 0xEF
0C8E  0020     MOVLB 0x0
0C8F  00EC     MOVWF 0x6C
0C90  3020     MOVLW 0x20
0C91  00ED     MOVWF d
0C92  0021     MOVLB 0x1
0C93  0821     MOVF r, W
0C94  0020     MOVLB 0x0
0C95  076C     ADDWF 0x6C, W
0C96  0086     MOVWF FSR1
0C97  0021     MOVLB 0x1
0C98  0822     MOVF 0xA2, W
0C99  0020     MOVLB 0x0
0C9A  3D6D     ADDWFC d, W
0C9B  0087     MOVWF FSR1H
0C9C  0801     MOVF INDF1, W
0C9D  0021     MOVLB 0x1
0C9E  00A0     MOVWF __pcstackBANK1
192:                           while( r < B_SIZE)
0C9F  3001     MOVLW 0x1
0CA0  0222     SUBWF 0xA2, W
0CA1  3000     MOVLW 0x0
0CA2  1903     BTFSC 0x83, 0x2
0CA3  0221     SUBWF r, W
0CA4  1803     BTFSC 0x83, 0x0
0CA5  2CD7     GOTO 0x4D7
0CBF  2C9F     GOTO 0x49F
193:                               B[0][r++] = last;   // filling
0CA6  30F0     MOVLW 0xF0
0CA7  0020     MOVLB 0x0
0CA8  00EC     MOVWF 0x6C
0CA9  3020     MOVLW 0x20
0CAA  00ED     MOVWF d
0CAB  0021     MOVLB 0x1
0CAC  0821     MOVF r, W
0CAD  0020     MOVLB 0x0
0CAE  076C     ADDWF 0x6C, W
0CAF  00EE     MOVWF 0x6E
0CB0  0021     MOVLB 0x1
0CB1  0822     MOVF 0xA2, W
0CB2  0020     MOVLB 0x0
0CB3  3D6D     ADDWFC d, W
0CB4  00EF     MOVWF 0x6F
0CB5  086E     MOVF 0x6E, W
0CB6  0086     MOVWF FSR1
0CB7  086F     MOVF 0x6F, W
0CB8  0087     MOVWF FSR1H
0CB9  0021     MOVLB 0x1
0CBA  0820     MOVF __pcstackBANK1, W
0CBB  0081     MOVWF 0x81
0CBC  0AA1     INCF r, F
0CBD  1903     BTFSC 0x83, 0x2
0CBE  0AA2     INCF 0xA2, F
194:                           
195:           //            LED3_LAT = 0;
196:                       }
197:                       else                    // buffer 0 is in use
198:                       {
199:                           memcpy( B[2], B[1], lc);
0CC0  30F0     MOVLW 0xF0
0CC1  0086     MOVWF 0x86
0CC2  3022     MOVLW 0x22
0CC3  0087     MOVWF 0x87
0CC4  30F0     MOVLW 0xF0
0CC5  0084     MOVWF 0x84
0CC6  3021     MOVLW 0x21
0CC7  0085     MOVWF 0x85
0CC8  0020     MOVLB 0x0
0CC9  0869     MOVF 0x69, W
0CCA  00ED     MOVWF d
0CCB  0868     MOVF lc, W
0CCC  00EC     MOVWF 0x6C
0CCD  0012     MOVIW FSR0++
0CCE  001E     MOVWI FSR1++
0CCF  3001     MOVLW 0x1
0CD0  02EC     SUBWF 0x6C, F
0CD1  3000     MOVLW 0x0
0CD2  3BED     SUBWFB d, F
0CD3  086D     MOVF d, W
0CD4  046C     IORWF 0x6C, W
0CD5  1D03     BTFSS STATUS, 0x2
0CD6  2CCD     GOTO 0x4CD
200:                       }
201:                       AEmptyFlag = FALSE;
0CD7  0021     MOVLB 0x1
0CD8  01D9     CLRF AEmptyFlag
202:           
203:                   while (!AEmptyFlag);
0CD9  0859     MOVF AEmptyFlag, W
0CDA  1903     BTFSC 0x83, 0x2
0CDB  2CD9     GOTO 0x4D9
204:                   }
205:               }
206:           
207:               // 16. stop playback
208:               HaltAudio();
0CDC  27E7     CALL 0x7E7
0CDD  3188     MOVLP 0x8
209:           
210:               // close file
211:               fcloseM( fp);
0CDE  0021     MOVLB 0x1
0CDF  0823     MOVF fp, W
0CE0  27C1     CALL 0x7C1
0CE1  3188     MOVLP 0x8
212:           
213:               // wait for button release if pressed to abort playback
214:               while( !SW1_GetValue());
0CE2  0020     MOVLB 0x0
0CE3  1A8C     BTFSC PORTA, 0x5
0CE4  0008     RETURN
0CE5  2CE2     GOTO 0x4E2
215:           
216:           } // Play
217:           
---  /Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/SDMMC.c  ------------
1:             /*
2:             ** SD/MMC card interface 
3:             ** 
4:             */
5:             
6:             #include "HardwareProfile.h"
7:             #include "SDMMC.h"
8:             
9:               // I/O definitions 
10:                #define SDWP    SD_WP    // Write Protect input
11:                #define SDCD    SD_CD    // Card Detect input
12:                #define SDCS    SD_CS    // Card Select output
13:              // Card Select TRIS control
14:                #define TRISCS() SD_CS_TRIS = 0;
15:            
16:            
17:            
18:            // SD card commands
19:            #define SD_RESET            0 // a.k.a. GO_IDLE (CMD0)
20:            #define INIT                1 // a.k.a. SEND_OP_COND (CMD1)
21:            #define SEND_CSD            9
22:            #define SEND_CID           10
23:            #define SET_BLEN           16
24:            #define READ_SINGLE        17
25:            #define WRITE_SINGLE       24
26:            #define APP_CMD            55
27:            #define SEND_APP_OP        41
28:            
29:            // SD card responses
30:            #define DATA_START       0xFE
31:            #define DATA_ACCEPT      0x05
32:            
33:            
34:            void InitSD( void)
35:            {
36:                SDCS = 1;
040C  0020     MOVLB 0x0
040D  1517     BSF LATB, 0x2
37:                TRISCS();           // make Card Select an output pin
040E  1112     BCF TRISB, 0x2
38:                
39:                // init the spi module for a slow (safe) clock speed first
40:                OpenSPISlow();
040F  2C28     GOTO 0x428
41:            
42:            } // InitSD
43:            
44:            
45:            #define ReadSPI()   WriteSPI( 0xFF)
46:            #define ClockSPI()  WriteSPI( 0xFF)
47:            #define DisableSD() SDCS = 1; ClockSPI()
48:            #define EnableSD()  SDCS = 0
49:            
50:            
51:            int DetectSD( void)
52:            {
53:                return ( !SDCD);  
0408  01F3     CLRF state
0409  0AF3     INCF state, F
040A  01F4     CLRF stereo
54:            } // Detect SD
040B  0008     RETURN
55:            
56:            int DetectWP( void)
57:            {
58:                return ( !SD_WE);
59:            } // Detect WP
60:            
61:            
62:            int SendSDCmd( unsigned char c, LBA a)
03C7  0020     MOVLB 0x0
03C8  00A1     MOVWF quotient
63:            {
64:                int i, r;
65:            
66:                // enable SD card
67:                EnableSD();
03C9  1117     BCF LATB, 0x2
68:            
69:                // send a comand packet (6 bytes)
70:                WriteSPI( c | 0x40);    // send command + frame bit
03CA  3840     IORLW 0x40
03CB  23FF     CALL 0x3FF
03CC  3180     MOVLP 0x0
71:                WriteSPI( a>>24);       // MSB of the address
03CD  0877     MOVF counter, W
03CE  23FF     CALL 0x3FF
03CF  3180     MOVLP 0x0
72:                WriteSPI( a>>16);
03D0  0876     MOVF 0x76, W
03D1  23FF     CALL 0x3FF
03D2  3180     MOVLP 0x0
73:                WriteSPI( a>>8);
03D3  0875     MOVF s, W
03D4  23FF     CALL 0x3FF
03D5  3180     MOVLP 0x0
74:                WriteSPI( a);           // LSB
03D6  0874     MOVF stereo, W
03D7  23FF     CALL 0x3FF
03D8  3180     MOVLP 0x0
75:                
76:                WriteSPI( 0x95);        // send CMD0 CRC
03D9  3095     MOVLW 0x95
03DA  23FF     CALL 0x3FF
03DB  3180     MOVLP 0x0
77:            
78:                // now wait for a response (allow for up to 8 bytes delay)
79:                i = 9;
03DC  3009     MOVLW 0x9
03DD  0020     MOVLB 0x0
03DE  00A2     MOVWF s2
03DF  01A3     CLRF f
80:                do {
81:                    r = ReadSPI();      // check if ready
03E0  30FF     MOVLW 0xFF
03E1  23FF     CALL 0x3FF
03E2  3180     MOVLP 0x0
03E3  0020     MOVLB 0x0
03E4  00A4     MOVWF n
03E5  01A5     CLRF 0x25
82:                    if ( r != 0xFF) break;
03E6  0A24     INCF n, W
03E7  0425     IORWF 0x25, W
03E8  1D03     BTFSS STATUS, 0x2
03E9  2BF9     GOTO 0x3F9
83:                } while ( --i > 0);
03EA  30FF     MOVLW 0xFF
03EB  07A2     ADDWF s2, F
03EC  1C03     BTFSS STATUS, 0x0
03ED  03A3     DECF f, F
03EE  0823     MOVF f, W
03EF  3A80     XORLW 0x80
03F0  00A0     MOVWF __pcstackBANK0
03F1  3080     MOVLW 0x80
03F2  0220     SUBWF __pcstackBANK0, W
03F3  1D03     BTFSS STATUS, 0x2
03F4  2BF7     GOTO 0x3F7
03F5  3001     MOVLW 0x1
03F6  0222     SUBWF s2, W
03F7  1803     BTFSC STATUS, 0x0
03F8  2BE0     GOTO 0x3E0
84:            
85:                return ( r);         
03F9  0020     MOVLB 0x0
03FA  0825     MOVF 0x25, W
03FB  00F5     MOVWF s
03FC  0824     MOVF n, W
03FD  00F4     MOVWF stereo
86:            
87:            /* return response
88:                FF - timeout 
89:                00 - command accepted
90:                01 - command received, card in idle state after RESET
91:            
92:            other codes:
93:                bit 0 = Idle state
94:                bit 1 = Erase Reset
95:                bit 2 = Illegal command
96:                bit 3 = Communication CRC error
97:                bit 4 = Erase sequence error
98:                bit 5 = Address error
99:                bit 6 = Parameter error
100:               bit 7 = Always 0
101:           */
102:               // NOTE CSCD is still low
103:           } // SendSDCmd
03FE  0008     RETURN
104:           
105:           
106:           int ReadSECTOR( LBA a, unsigned char *p)
107:           // a        LBA of sector requested
108:           // p        pointer to sector buffer
109:           // returns  TRUE if successful
110:           {
111:               int r, i;
112:               unsigned char c =0;
02D7  01B2     CLRF c
113:           
114:           //    LED1_LAT = 1;
115:               r = SendSDCmd( READ_SINGLE, ( a << 9));
02D8  0826     MOVF a, W
02D9  00AC     MOVWF flag
02DA  0827     MOVF 0x27, W
02DB  00AD     MOVWF idx
02DC  0828     MOVF 0x28, W
02DD  00AE     MOVWF val
02DE  0829     MOVF r, W
02DF  00AF     MOVWF 0x2F
02E0  3009     MOVLW 0x9
02E1  35AC     LSLF flag, F
02E2  0DAD     RLF idx, F
02E3  0DAE     RLF val, F
02E4  0DAF     RLF 0x2F, F
02E5  0B89     DECFSZ WREG, F
02E6  2AE1     GOTO 0x2E1
02E7  082F     MOVF 0x2F, W
02E8  00F7     MOVWF counter
02E9  082E     MOVF val, W
02EA  00F6     MOVWF 0x76
02EB  082D     MOVF idx, W
02EC  00F5     MOVWF s
02ED  082C     MOVF flag, W
02EE  00F4     MOVWF stereo
02EF  3011     MOVLW 0x11
02F0  23C7     CALL 0x3C7
02F1  3180     MOVLP 0x0
02F2  0875     MOVF s, W
02F3  00B4     MOVWF 0x34
02F4  0874     MOVF stereo, W
02F5  00B3     MOVWF r
116:               if ( r == 0)    // check if command was accepted
02F6  0434     IORWF 0x34, W
02F7  1D03     BTFSS STATUS, 0x2
02F8  2B4C     GOTO 0x34C
117:               {  
118:                   // wait for a response
119:                   i = 10000;
02F9  3010     MOVLW 0x10
02FA  00B0     MOVWF i
02FB  3027     MOVLW 0x27
02FC  00B1     MOVWF width
120:                   do{
121:                       r = ReadSPI();
02FD  30FF     MOVLW 0xFF
02FE  23FF     CALL 0x3FF
02FF  3180     MOVLP 0x0
0300  0020     MOVLB 0x0
0301  00B3     MOVWF r
0303  01B4     CLRF 0x34
122:                       if ( r == DATA_START) break;
0302  30FE     MOVLW 0xFE
0304  0633     XORWF r, W
0305  0434     IORWF 0x34, W
0306  1903     BTFSC STATUS, 0x2
0307  2B17     GOTO 0x317
123:                   }while( --i>0);
0308  30FF     MOVLW 0xFF
0309  07B0     ADDWF i, F
030A  1C03     BTFSS STATUS, 0x0
030B  03B1     DECF width, F
030C  0831     MOVF width, W
030D  3A80     XORLW 0x80
030E  00AC     MOVWF flag
030F  3080     MOVLW 0x80
0310  022C     SUBWF flag, W
0311  1D03     BTFSS STATUS, 0x2
0312  2B15     GOTO 0x315
0313  3001     MOVLW 0x1
0314  0230     SUBWF i, W
0315  1803     BTFSC STATUS, 0x0
0316  2AFD     GOTO 0x2FD
124:           
125:           //        LED1_LAT = 0;
126:           //        LED2_LAT = 1;
127:                 // if it did not timeout, read a 512 byte sector of data
128:                   if ( i)
0317  0020     MOVLB 0x0
0318  0830     MOVF i, W
0319  0431     IORWF width, W
031A  1903     BTFSC STATUS, 0x2
031B  2B4C     GOTO 0x34C
129:                   {
130:           //            for( i=0; i<512; i++)
131:                       do
132:                       {
133:                           SSP1BUF = 0xFF;               
031C  30FF     MOVLW 0xFF
031D  0023     MOVLB 0x3
031E  008C     MOVWF SSP1BUF
134:                           asm("NOP");
031F  0000     NOP
135:                           asm("NOP");
0320  0000     NOP
136:                           asm("NOP");
0321  0000     NOP
137:                           asm("NOP");
0322  0000     NOP
138:                           *p++ = SSP1BUF;
0323  0020     MOVLB 0x0
0324  082A     MOVF p, W
0325  0086     MOVWF FSR1
0326  082B     MOVF i, W
0327  0087     MOVWF FSR1H
0328  0023     MOVLB 0x3
0329  080C     MOVF SSP1BUF, W
032A  0081     MOVWF 0x181
032B  0020     MOVLB 0x0
032C  0AAA     INCF p, F
032D  1903     BTFSC STATUS, 0x2
032E  0AAB     INCF i, F
139:                       } while ( --c != 0);
032F  0BB2     DECFSZ c, F
0330  2B1C     GOTO 0x31C
140:           
141:                       do
142:                       {
143:                           SSP1BUF = 0xFF;
0331  30FF     MOVLW 0xFF
0332  0023     MOVLB 0x3
0333  008C     MOVWF SSP1BUF
144:                           asm("NOP");
0334  0000     NOP
145:                           asm("NOP");
0335  0000     NOP
146:                           asm("NOP");
0336  0000     NOP
147:                           asm("NOP");
0337  0000     NOP
148:                           *p++ = SSP1BUF;
0338  0020     MOVLB 0x0
0339  082A     MOVF p, W
033A  0086     MOVWF FSR1
033B  082B     MOVF i, W
033C  0087     MOVWF FSR1H
033D  0023     MOVLB 0x3
033E  080C     MOVF SSP1BUF, W
033F  0081     MOVWF 0x181
0340  0020     MOVLB 0x0
0341  0AAA     INCF p, F
0342  1903     BTFSC STATUS, 0x2
0343  0AAB     INCF i, F
149:                       } while ( --c != 0);
0344  0BB2     DECFSZ c, F
0345  2B31     GOTO 0x331
150:           //        LED2_LAT = 0;
151:           
152:                       // ignore CRC
153:                       ClockSPI();
0346  30FF     MOVLW 0xFF
0347  23FF     CALL 0x3FF
0348  3180     MOVLP 0x0
154:                       ClockSPI();
0349  30FF     MOVLW 0xFF
034A  23FF     CALL 0x3FF
034B  3180     MOVLP 0x0
155:                   } // data arrived
156:               } // command accepted
157:           
158:               // remember to disable the card
159:               DisableSD();
034C  0020     MOVLB 0x0
034D  1517     BSF LATB, 0x2
034E  30FF     MOVLW 0xFF
034F  23FF     CALL 0x3FF
0350  3180     MOVLP 0x0
160:               //READ_LED = 0;
161:           
162:               return ( r == DATA_START);  // return TRUE if successful
0351  30FE     MOVLW 0xFE
0352  0020     MOVLB 0x0
0353  0633     XORWF r, W
0354  0434     IORWF 0x34, W
0355  1D03     BTFSS STATUS, 0x2
0356  2B59     GOTO 0x359
0357  3001     MOVLW 0x1
0358  2B5A     GOTO 0x35A
0359  3000     MOVLW 0x0
035A  00A6     MOVWF a
035B  01A7     CLRF 0x27
163:           } // ReadSECTOR
035C  0008     RETURN
164:           
165:           
166:           int InitMedia( void)
167:           {
168:               int i, r;
169:           
170:               // 1. with the card not selected     
171:               DisableSD();
035D  0020     MOVLB 0x0
035E  1517     BSF LATB, 0x2
035F  30FF     MOVLW 0xFF
0360  23FF     CALL 0x3FF
0361  3180     MOVLP 0x0
172:           
173:               // 2. send 80 clock cycles start up
174:               for ( i=0; i<10; i++)
0362  0020     MOVLB 0x0
0363  01AB     CLRF i
0364  01AC     CLRF flag
0368  0020     MOVLB 0x0
0369  0AAB     INCF i, F
036A  1903     BTFSC STATUS, 0x2
036B  0AAC     INCF flag, F
036C  082C     MOVF flag, W
036D  3A80     XORLW 0x80
036E  00A8     MOVWF 0x28
036F  3080     MOVLW 0x80
0370  0228     SUBWF 0x28, W
0371  1D03     BTFSS STATUS, 0x2
0372  2B75     GOTO 0x375
0373  300A     MOVLW 0xA
0374  022B     SUBWF i, W
0375  1C03     BTFSS STATUS, 0x0
0376  2B65     GOTO 0x365
175:                   ClockSPI();
0365  30FF     MOVLW 0xFF
0366  23FF     CALL 0x3FF
0367  3180     MOVLP 0x0
176:           
177:               // 3. now select the card
178:               EnableSD();
0377  0020     MOVLB 0x0
0378  1117     BCF LATB, 0x2
179:           
180:               // 4. send a reset command to enter SPI mode
181:               r = SendSDCmd( SD_RESET, 0); DisableSD();
0379  3000     MOVLW 0x0
037A  01F4     CLRF stereo
037B  01F5     CLRF s
037C  01F6     CLRF 0x76
037D  01F7     CLRF counter
037E  23C7     CALL 0x3C7
037F  3180     MOVLP 0x0
0380  0875     MOVF s, W
0381  00AA     MOVWF p
0382  0874     MOVF stereo, W
0383  00A9     MOVWF r
0384  1517     BSF LATB, 0x2
0385  30FF     MOVLW 0xFF
0386  23FF     CALL 0x3FF
0387  3180     MOVLP 0x0
182:               if ( r != 1)
0388  0020     MOVLB 0x0
0389  0329     DECF r, W
038A  042A     IORWF p, W
038B  1903     BTFSC STATUS, 0x2
038C  2B91     GOTO 0x391
183:                   return 0x84;
038D  3084     MOVLW 0x84
038E  00A6     MOVWF a
038F  01A7     CLRF 0x27
0390  0008     RETURN
184:           
185:               // 5. send repeatedly INIT  
186:               i = 10000;  // up to .3 sec before timeout
0391  3010     MOVLW 0x10
0392  00AB     MOVWF i
0393  3027     MOVLW 0x27
0394  00AC     MOVWF flag
187:               do {
188:                   r = SendSDCmd( INIT, 0); DisableSD();
0395  3001     MOVLW 0x1
0396  01F4     CLRF stereo
0397  01F5     CLRF s
0398  01F6     CLRF 0x76
0399  01F7     CLRF counter
039A  23C7     CALL 0x3C7
039B  3180     MOVLP 0x0
039C  0875     MOVF s, W
039D  00AA     MOVWF p
039E  0874     MOVF stereo, W
039F  00A9     MOVWF r
03A0  1517     BSF LATB, 0x2
03A1  30FF     MOVLW 0xFF
03A2  23FF     CALL 0x3FF
03A3  3180     MOVLP 0x0
189:                   if ( !r) break; 
03A4  0020     MOVLB 0x0
03A5  0829     MOVF r, W
03A6  042A     IORWF p, W
03A7  1903     BTFSC STATUS, 0x2
03A8  2BB8     GOTO 0x3B8
190:               } while( --i > 0);
03A9  30FF     MOVLW 0xFF
03AA  07AB     ADDWF i, F
03AB  1C03     BTFSS STATUS, 0x0
03AC  03AC     DECF flag, F
03AD  082C     MOVF flag, W
03AE  3A80     XORLW 0x80
03AF  00A8     MOVWF 0x28
03B0  3080     MOVLW 0x80
03B1  0228     SUBWF 0x28, W
03B2  1D03     BTFSS STATUS, 0x2
03B3  2BB6     GOTO 0x3B6
03B4  3001     MOVLW 0x1
03B5  022B     SUBWF i, W
03B6  1803     BTFSC STATUS, 0x0
03B7  2B95     GOTO 0x395
191:               if ( i==0)   
03B8  0020     MOVLB 0x0
03B9  082B     MOVF i, W
03BA  042C     IORWF flag, W
03BB  1D03     BTFSS STATUS, 0x2
03BC  2BC1     GOTO 0x3C1
192:                   return 0x85;       // timed out 
03BD  3085     MOVLW 0x85
03BE  00A6     MOVWF a
03BF  01A7     CLRF 0x27
03C0  0008     RETURN
193:               
194:               // 6. increase speed
195:               OpenSPIFast();
03C1  318A     MOVLP 0xA
03C2  2204     CALL 0x204
196:               return 0;           
03C3  0020     MOVLB 0x0
03C4  01A6     CLRF a
03C5  01A7     CLRF 0x27
197:           
198:           } // InitMedia
03C6  0008     RETURN
---  /Users/m91329/Developer/MPLABXProjects/XPRESS/In_10_Lines-Extra/19-WAVPlayer.X/AudioDAC.c  ---------
1:             /*
2:             ** AudioDAC.c
3:             **
4:             */
5:             #include "AudioDAC.h"
6:             
7:             // global definitions
8:             char           CurBuf;       // index of buffer in use
9:             volatile char  AEmptyFlag;   // flag a buffer needs to be filled
10:            
11:            // internal variables
12:            //char Stereo;                 // flag stereo play back
13:            //char Fix;                    // sign fix for 16-bit samples
14:            char Skip;                   // skip factor, reduce sample/rate
15:            char Size;                   // sample size (8 or 16-bit)
16:            
17:            // local definitions
18:            unsigned char *BPtr;         // pointer inside active buffer
19:            unsigned char BCount;        // count bytes used
20:            //unsigned char Bytes;         // number of bytes per sample
21:            
22:            void InitAudio(char skip, char size, char stereo)
055C  0020     MOVLB 0x0
055D  00A0     MOVWF __pcstackBANK0
23:            {
24:                // 1. init pointers 
25:                CurBuf = 0;             // start with buffer0 active first
055F  01F8     CLRF CurBuf
26:                BPtr = &B[ CurBuf][size-1];
055E  3020     MOVLW 0x20
0560  0021     MOVLB 0x1
0561  00D8     MOVWF 0xD8
0562  30EF     MOVLW 0xEF
0563  00D7     MOVWF BPtr
0564  0873     MOVF 0xF3, W
0565  07D7     ADDWF BPtr, F
0566  1803     BTFSC 0x83, 0x0
0567  0AD8     INCF 0xD8, F
0568  0878     MOVF 0xF8, W
0569  00F5     MOVWF 0xF5
056A  01F6     CLRF 0xF6
056B  00F6     MOVWF 0xF6
056C  01F5     CLRF 0xF5
056D  0875     MOVF 0xF5, W
056E  07D7     ADDWF BPtr, F
056F  0876     MOVF 0xF6, W
0570  3DD8     ADDWFC 0xD8, F
27:                BCount = B_SIZE;        // number of samples to be played
0571  01DA     CLRF BCount
28:                AEmptyFlag = 0;
0572  01D9     CLRF AEmptyFlag
29:                Skip = skip;
0573  0020     MOVLB 0x0
0574  0820     MOVF __pcstackBANK0, W
0575  00FA     MOVWF Skip
30:            //    Fix = (size==2)? 0x80 : 0;  // sign correction for 16-bit
31:            //    Stereo = stereo;
32:                Size = size;
0576  0873     MOVF state, W
0577  00F9     MOVWF Size
33:            //    Bytes = size*stereo;
34:            } // InitAudio
0578  0008     RETURN
35:            
36:            
37:            void StartAudio(void)
38:            {
39:                TMR2_SetInterruptHandler(TMR2_CallBack);
0FE8  30A6     MOVLW 0xA6
0FE9  00F3     MOVWF state
0FEA  3004     MOVLW 0x4
0FEB  00F4     MOVWF stereo
0FEC  27F2     CALL 0x7F2
0FED  3188     MOVLP 0x8
40:                // 1. init the timebase
41:                TMR2_StartTimer();
0FEE  27FF     CALL 0x7FF
42:            
43:                // 2. activate the Audio DAC 
44:                // configured in the System init
45:                INTERRUPT_PeripheralInterruptEnable();
0FEF  170B     BSF INTCON, 0x6
46:                INTERRUPT_GlobalInterruptEnable();
0FF0  178B     BSF INTCON, 0x7
47:            } // start audio
0FF1  0008     RETURN
48:            
49:            
50:            void HaltAudio(void)
51:            {
52:                TMR2_StopTimer();
0FE7  2FF9     GOTO 0x7F9
53:            } // HaltAudio
54:            
55:            
56:            void TMR2_CallBack(void)
57:            {
58:                static int sk = 1;
002A  3001     MOVLW 0x1
002C  3000     MOVLW 0x0
59:            //    unsigned char temp;
60:            
61:                // 1. skip to increase the bitrate (avoid PWM noise)
62:                if (--sk == 0)
04A6  30FF     MOVLW 0xFF
04A7  07DF     ADDWF 0x5F, F
04A8  1C03     BTFSS STATUS, 0x0
04A9  03E0     DECF 0x60, F
04AA  085F     MOVF 0x5F, W
04AB  0460     IORWF 0x60, W
04AC  1D03     BTFSS STATUS, 0x2
04AD  0008     RETURN
63:                 {
64:                    // reload the skip 
65:                    sk = Skip;
04AE  087A     MOVF Skip, W
04AF  00DF     MOVWF 0x5F
04B0  01E0     CLRF 0x60
66:            
67:                    // 2. load the new samples for the next cycle
68:                    PWM7DCH =  *BPtr ;     // ^ Fix);
04B1  0857     MOVF size, W
04B2  0086     MOVWF FSR1
04B3  0858     MOVF 0x58, W
04B4  0087     MOVWF FSR1H
04B5  0801     MOVF INDF1, W
04B6  0027     MOVLB 0x7
04B7  0091     MOVWF PWM7DCH
69:            //        if (Stereo==2)
70:            //            temp = 30 + (*(BPtr + Size) ^ Fix);
71:            //        else    // mono
72:            //            OC2RS = OC1RS;
73:            //        BPtr += Bytes;
74:                    BPtr++;
04B8  0021     MOVLB 0x1
04B9  0AD7     INCF BPtr, F
04BA  1903     BTFSC 0x83, 0x2
04BB  0AD8     INCF 0xD8, F
75:            
76:                    // 3. check if buffer emptied
77:            //        BCount -= Bytes;
78:                    BCount--;
04BC  03DA     DECF BCount, F
79:                    if (BCount == 0)
04BD  085A     MOVF BCount, W
04BE  1D03     BTFSS 0x83, 0x2
04BF  0008     RETURN
80:                    {
81:                        // 3.1 swap buffers
82:                        CurBuf = 2 - CurBuf;
04C0  0878     MOVF 0xF8, W
04C1  3C02     SUBLW 0x2
04C2  00F8     MOVWF 0xF8
83:                        BPtr = &B[ CurBuf][Size-1];
04C3  3020     MOVLW 0x20
04C4  00D8     MOVWF 0xD8
04C5  30EF     MOVLW 0xEF
04C6  00D7     MOVWF BPtr
04C7  0879     MOVF 0xF9, W
04C8  07D7     ADDWF BPtr, F
04C9  1803     BTFSC 0x83, 0x0
04CA  0AD8     INCF 0xD8, F
04CB  0878     MOVF 0xF8, W
04CC  00F0     MOVWF 0xF0
04CD  01F1     CLRF 0xF1
04CE  00F1     MOVWF 0xF1
04CF  01F0     CLRF 0xF0
04D0  0870     MOVF 0xF0, W
04D1  07D7     ADDWF BPtr, F
04D2  0871     MOVF 0xF1, W
04D3  3DD8     ADDWFC 0xD8, F
84:                        
85:                        // 3.2 buffer refilled
86:                        BCount = B_SIZE;
04D5  01DA     CLRF BCount
87:                
88:                        // 3.3 flag a new buffer needs to be filled
89:                        AEmptyFlag = 1;
04D4  3001     MOVLW 0x1
04D6  00D9     MOVWF AEmptyFlag
90:                    }
91:                } 
92:                
93:            } // T2 Interrupt
04D7  0008     RETURN
94:            
---  /Applications/microchip/xc8/v1.35/sources/common/puts.c  -------------------------------------------
1:             /*
2:              *	puts and fputs for HI-TECH C stdio
3:              */
4:             
5:             #include	<stdio.h>
6:             #include	<conio.h>
7:             
8:             puts(const char * s)
9:             {
10:            	cputs(s);
0877  0821     MOVF r, W
0878  00F6     MOVWF 0xF6
0879  0820     MOVF __pcstackBANK1, W
087A  00F5     MOVWF 0xF5
087B  3185     MOVLP 0x5
087C  2579     CALL 0x579
087D  3188     MOVLP 0x8
11:            	putch('\n');
087E  300A     MOVLW 0xA
087F  2982     GOTO 0x182
12:            }
---  /Applications/microchip/xc8/v1.35/sources/common/memcmp.c  -----------------------------------------
1:             #include	<string.h>
2:             
3:             memcmp(const void *s1, const void *s2, size_t n)
4:             {
5:             	while(n-- != 0)  {
04D8  3001     MOVLW 0x1
04D9  02A4     SUBWF 0xA4, F
04DA  3000     MOVLW 0x0
04DB  3BA5     SUBWFB lc, F
04DC  0F24     INCFSZ 0xA4, W
04DD  2CE1     GOTO 0x4E1
04DE  0A25     INCF lc, W
04DF  1903     BTFSC 0x83, 0x2
04E0  2D05     GOTO 0x505
0504  2CD8     GOTO 0x4D8
6:             		if(*((const unsigned char *)s1) != *((const unsigned char *)s2))
04E1  0822     MOVF 0xA2, W
04E2  0084     MOVWF 0x84
04E3  0823     MOVF fp, W
04E4  0085     MOVWF 0x85
04E5  0800     MOVF 0x80, W
04E6  00F3     MOVWF 0xF3
04E7  0820     MOVF __pcstackBANK1, W
04E8  0086     MOVWF 0x86
04E9  0821     MOVF r, W
04EA  0087     MOVWF 0x87
04EB  0801     MOVF 0x81, W
04EC  0673     XORWF 0xF3, W
04ED  1903     BTFSC 0x83, 0x2
04EE  2CFE     GOTO 0x4FE
7:             			return *((const unsigned char *)s1) - *((const unsigned char *)s2);
04EF  0820     MOVF __pcstackBANK1, W
04F0  0086     MOVWF 0x86
04F1  0821     MOVF r, W
04F2  0087     MOVWF 0x87
04F3  0822     MOVF 0xA2, W
04F4  0084     MOVWF 0x84
04F5  0823     MOVF fp, W
04F6  0085     MOVWF 0x85
04F7  0800     MOVF 0x80, W
04F8  0201     SUBWF 0x81, W
04F9  00A0     MOVWF __pcstackBANK1
04FA  01A1     CLRF r
04FB  1C03     BTFSS 0x83, 0x0
04FC  03A1     DECF r, F
04FD  0008     RETURN
8:             		(*(const unsigned char **)&s1)++;
04FE  0AA0     INCF __pcstackBANK1, F
04FF  1903     BTFSC 0x83, 0x2
0500  0AA1     INCF r, F
9:             		(*(const unsigned char **)&s2)++;
0501  0AA2     INCF 0xA2, F
0502  1903     BTFSC 0x83, 0x2
0503  0AA3     INCF fp, F
10:            	}
11:            	return 0;
0505  01A0     CLRF __pcstackBANK1
0506  01A1     CLRF r
12:            }
0507  0008     RETURN
---  /Applications/microchip/xc8/v1.35/sources/common/lwdiv.c  ------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
0537  01A1     CLRF r
0538  01A2     CLRF 0xA2
15:            	if(divisor != 0) {
0539  0873     MOVF 0xF3, W
053A  0474     IORWF 0xF4, W
053B  1903     BTFSC 0x83, 0x2
053C  2D57     GOTO 0x557
16:            		counter = 1;
053D  01A0     CLRF __pcstackBANK1
17:            		while((divisor & 0x8000) == 0) {
053F  1BF4     BTFSC 0xF4, 0x7
0540  2D44     GOTO 0x544
0543  2D3E     GOTO 0x53E
18:            			divisor <<= 1;
0541  35F3     LSLF 0xF3, F
0542  0DF4     RLF 0xF4, F
19:            			counter++;
053E  0AA0     INCF __pcstackBANK1, F
20:            		}
21:            		do {
22:            			quotient <<= 1;
0544  35A1     LSLF r, F
0545  0DA2     RLF 0xA2, F
23:            			if(divisor <= dividend) {
0546  0874     MOVF 0xF4, W
0547  0276     SUBWF 0xF6, W
0548  1D03     BTFSS 0x83, 0x2
0549  2D4C     GOTO 0x54C
054A  0873     MOVF 0xF3, W
054B  0275     SUBWF 0xF5, W
054C  1C03     BTFSS 0x83, 0x0
054D  2D53     GOTO 0x553
24:            				dividend -= divisor;
054E  0873     MOVF 0xF3, W
054F  02F5     SUBWF 0xF5, F
0550  0874     MOVF 0xF4, W
0551  3BF6     SUBWFB 0xF6, F
25:            				quotient |= 1;
0552  1421     BSF r, 0x0
26:            			}
27:            			divisor >>= 1;
0553  36F4     LSRF 0xF4, F
0554  0CF3     RRF 0xF3, F
28:            		} while(--counter != 0);
0555  0BA0     DECFSZ __pcstackBANK1, F
0556  2D44     GOTO 0x544
29:            	}
30:            	return quotient;
0557  0822     MOVF 0xA2, W
0558  00F4     MOVWF 0xF4
0559  0821     MOVF r, W
055A  00F3     MOVWF 0xF3
31:            }
055B  0008     RETURN
---  /Applications/microchip/xc8/v1.35/sources/common/lldiv.c  ------------------------------------------
1:             // long unsigned unsigned division
2:             
3:             unsigned long int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lldiv(unsigned long int divisor, unsigned long int dividend)
7:             #else
8:             __lldiv(unsigned long int dividend, unsigned long int divisor)
9:             #endif
10:            {
11:            	unsigned long int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
0430  01F3     CLRF 0xF3
0431  01F4     CLRF 0xF4
0432  01F5     CLRF 0xF5
0433  01F6     CLRF 0xF6
15:            	if(divisor != 0) {
0434  0823     MOVF fp, W
0435  0422     IORWF 0xA2, W
0436  0421     IORWF r, W
0437  0420     IORWF __pcstackBANK1, W
0438  1903     BTFSC 0x83, 0x2
0439  2C66     GOTO 0x466
16:            		counter = 1;
043A  01F7     CLRF 0xF7
17:            		while((divisor & 0x80000000UL) == 0) {
043C  1BA3     BTFSC fp, 0x7
043D  2C43     GOTO 0x443
0442  2C3B     GOTO 0x43B
18:            			divisor <<= 1;
043E  35A0     LSLF __pcstackBANK1, F
043F  0DA1     RLF r, F
0440  0DA2     RLF 0xA2, F
0441  0DA3     RLF fp, F
19:            			counter++;
043B  0AF7     INCF 0xF7, F
20:            		}
21:            		do {
22:            			quotient <<= 1;
0443  35F3     LSLF 0xF3, F
0444  0DF4     RLF 0xF4, F
0445  0DF5     RLF 0xF5, F
0446  0DF6     RLF 0xF6, F
23:            			if(divisor <= dividend) {
0447  0823     MOVF fp, W
0448  0227     SUBWF 0xA7, W
0449  1D03     BTFSS 0x83, 0x2
044A  2C55     GOTO 0x455
044B  0822     MOVF 0xA2, W
044C  0226     SUBWF 0xA6, W
044D  1D03     BTFSS 0x83, 0x2
044E  2C55     GOTO 0x455
044F  0821     MOVF r, W
0450  0225     SUBWF lc, W
0451  1D03     BTFSS 0x83, 0x2
0452  2C55     GOTO 0x455
0453  0820     MOVF __pcstackBANK1, W
0454  0224     SUBWF 0xA4, W
0455  1C03     BTFSS 0x83, 0x0
0456  2C60     GOTO 0x460
24:            				dividend -= divisor;
0457  0820     MOVF __pcstackBANK1, W
0458  02A4     SUBWF 0xA4, F
0459  0821     MOVF r, W
045A  3BA5     SUBWFB lc, F
045B  0822     MOVF 0xA2, W
045C  3BA6     SUBWFB 0xA6, F
045D  0823     MOVF fp, W
045E  3BA7     SUBWFB 0xA7, F
25:            				quotient |= 1;
045F  1473     BSF 0xF3, 0x0
26:            			}
27:            			divisor >>= 1;
0460  36A3     LSRF fp, F
0461  0CA2     RRF 0xA2, F
0462  0CA1     RRF r, F
0463  0CA0     RRF __pcstackBANK1, F
28:            		} while(--counter != 0);
0464  0BF7     DECFSZ 0xF7, F
0465  2C43     GOTO 0x443
29:            	}
30:            	return quotient;
0466  0876     MOVF 0xF6, W
0467  00A3     MOVWF fp
0468  0875     MOVF 0xF5, W
0469  00A2     MOVWF 0xA2
046A  0874     MOVF 0xF4, W
046B  00A1     MOVWF r
046C  0873     MOVF 0xF3, W
046D  00A0     MOVWF __pcstackBANK1
31:            }
046E  0008     RETURN
---  /Applications/microchip/xc8/v1.35/sources/common/isdigit.c  ----------------------------------------
1:             #include	<ctype.h>
2:             
3:             #ifndef isdigit
4:             
5:             #ifdef _CTYPE_BIT_FUNCS_
6:             
7:             bit
8:             isdigit(char c)
0986  00F4     MOVWF 0xF4
9:             #else
10:            int
11:            isdigit(int c)
12:            #endif
13:            {
14:            	return c <= '9' && c >= '0';
0987  303A     MOVLW 0x3A
0988  01F3     CLRF 0xF3
0989  0274     SUBWF 0xF4, W
098A  1803     BTFSC 0x83, 0x0
098B  2992     GOTO 0x192
098C  3030     MOVLW 0x30
098D  0274     SUBWF 0xF4, W
098E  1C03     BTFSS 0x83, 0x0
098F  2992     GOTO 0x192
0990  01F3     CLRF 0xF3
0991  0AF3     INCF 0xF3, F
0992  0C73     RRF 0xF3, W
15:            }
0993  0008     RETURN
16:            
17:            #endif
---  /Applications/microchip/xc8/v1.35/sources/common/doprnt.c  -----------------------------------------
1:             #include	<stdio.h>
2:             #include	<ctype.h>
3:             #include	<stdlib.h>
4:             #include	<string.h>
5:             #include	<stdarg.h>
6:             #include	<conio.h>
7:             #include	<sys.h>
8:             #include	<math.h>
9:             #include	<float.h>
10:            
11:            // disable unused variable warnings
12:            // the compiler will optimize them away, so no harm is done
13:            #pragma warning disable 350
14:            
15:            /*
16:             *	doprnt - versions depends on conditional compilation.
17:             *	Can be customized with defines.
18:             *
19:             *	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
20:             *
21:             *	$Header$
22:             *
23:             */
24:            
25:            #ifndef	CUSTOM_PRINTF
26:            
27:             // define all flags, thus enabling all features
28:            
29:            #define	BASEM	0xC0
30:            #define	OPTSIGN	0x00
31:            #define	SPCSIGN	0x01
32:            #define	MANSIGN	0x02
33:            #define	NEGSIGN	0x03
34:            #define	FILL	0x04
35:            #define	LEFT	0x08
36:            #define	LONG	0x10
37:            #define	UPCASE	0x20
38:            #define	TEN		0x00
39:            #define	EIGHT	0x40
40:            #define	SIXTEEN	0x80
41:            #define	UNSIGN	0xC0
42:            #ifdef	__FLOAT
43:            #define	EFMT	0x100
44:            #define	GFMT	0x200
45:            #define	FFMT	0x400
46:            #endif	// __FLOAT
47:            #define	ALTERN	0x800
48:            #define POINTER	0x2000
49:            #define HEXUPCASE
50:            #define HEXLOWCASE
51:            
52:             // defines for ifdef only, not used as flags
53:            #define	WIDTH	1		// width used
54:            #define	STAR	1		// width or precision as an arg
55:            #define	STRING	1		// %s used
56:            #define	CHAR	1		// %c used
57:            #define	PERCPERC	1	// %% used
58:            #define	SPRINTF	1		// sprintf is used
59:            #define	PRINTF	1		// printf is used
60:            #define	MULTRAD	1		// handle multiple radices
61:            #define	RETVALUE	1	// return value is needed
62:            
63:            #else	// CUSTOM_PRINTF
64:            
65:            #if	defined(HEXUPCASE) || defined(HEXLOWCASE)
66:            #define	SIXTEEN
67:            #endif
68:            
69:            #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
70:            #ifndef UPCASE
71:            #define	UPCASE
72:            #endif
73:            #endif
74:            
75:             // make sure we have the right values for each define
76:            #ifdef	OPTSIGN
77:            #undef	OPTSIGN
78:            #define	OPTSIGN	0x00
79:            #endif
80:            #ifdef	SPCSIGN
81:            #undef	SPCSIGN
82:            #define	SPCSIGN	0x01
83:            #endif
84:            #ifdef	MANSIGN
85:            #undef	MANSIGN
86:            #define	MANSIGN	0x02
87:            #define	SPCSIGN	0x01
88:            #endif
89:            #ifdef	NEGSIGN
90:            #undef	NEGSIGN
91:            #define	NEGSIGN	0x03
92:            #endif
93:            #ifdef	FILL
94:            #define	WIDTH	1
95:            #undef	FILL
96:            #define	FILL	0x04
97:            #endif
98:            #ifdef	LEFT
99:            #undef	LEFT
100:            // LEFT without WIDTH is meaningless
101:           #ifdef	WIDTH
102:           #define	LEFT	0x08
103:           #endif
104:           #endif
105:           #ifdef	LONG
106:           #undef	LONG
107:           #define	LONG	0x10
108:           #define	__LONG	1
109:           #endif
110:           #ifdef	UPCASE
111:           #undef	UPCASE
112:           #define	UPCASE	0x20
113:           #endif
114:           #ifdef	TEN	
115:           #undef	TEN	
116:           #define	TEN		0x00
117:           #endif
118:           #ifdef	EIGHT
119:           #undef	EIGHT
120:           #define	EIGHT	0x40
121:           #endif
122:           #ifdef	SIXTEEN
123:           #undef	SIXTEEN
124:           #define	SIXTEEN	0x80
125:           #endif
126:           #ifdef	UNSIGN
127:           #undef	UNSIGN
128:           #define	UNSIGN	0xC0
129:           #endif
130:           #ifdef	EFMT
131:           #undef	EFMT
132:           #define	EFMT	0x100
133:           #endif
134:           #ifdef	GFMT
135:           #undef	GFMT
136:           #define	GFMT	0x200
137:           #endif
138:           #ifdef	FFMT
139:           #undef	FFMT
140:           #define	FFMT	0x400
141:           #endif
142:           #ifdef	ALTERN
143:           #undef	ALTERN
144:           #define	ALTERN	0x800
145:           #endif
146:           #ifdef	POINTER
147:           #undef	POINTER
148:           #define POINTER	0x2000
149:           #ifndef	SIXTEEN
150:           #define	SIXTEEN	0x80
151:           #endif
152:           #endif
153:           #ifdef	PRECISION
154:           #undef	PRECISION
155:           #define PRECISION	0x4000
156:           #endif
157:           
158:           #if	defined(TEN) && !defined(EIGHT) && !defined(SIXTEEN) && defined(UNSIGN)
159:           #undef	UNSIGN
160:           #define	UNSIGN	0x40
161:           #define	BASEM	UNSIGN
162:           #endif
163:           #if	defined(UNSIGN) && (defined(EIGHT) || defined(SIXTEEN))
164:           #define	MULTRAD	1
165:           #define	BASEM	(UNSIGN)
166:           #endif
167:           #if	defined(TEN) && !defined(SIXTEEN) && defined(EIGHT) && !defined(UNSIGN)
168:           #define	BASEM	EIGHT
169:           #define	MULTRAD	1
170:           #endif
171:           #if	defined(TEN) && defined(SIXTEEN) && !defined(EIGHT) && !defined(UNSIGN)
172:           #define	BASEM	SIXTEEN
173:           #define	MULTRAD	1
174:           #endif
175:           #if	defined(SIXTEEN) && defined(EIGHT) && !defined(BASEM)
176:           #define	BASEM	(SIXTEEN|EIGHT)
177:           #define	MULTRAD	1
178:           #endif
179:           
180:           #endif
181:           
182:            // float code needs these flags
183:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT)
184:           #ifndef	__FLOAT
185:           #define	__FLOAT	1
186:           #endif
187:           #define	FLOATFORMAT	0x700
188:           #ifdef	PRECISION
189:           #define	DEFPREC	0x1000
190:           #endif
191:           #endif
192:           
193:           #ifdef	__FLOAT
194:           //#ifndef	MANSIGN
195:           //#define	MANSIGN	0x02
196:           //#endif
197:           //#ifndef	SPCSIGN
198:           //#define	SPCSIGN	0x01
199:           //#endif
200:           #ifndef	NEGSIGN
201:           #define	NEGSIGN	0x03
202:           #endif
203:           //#ifndef	WIDTH
204:           //#define	WIDTH	1
205:           //#endif
206:           #endif
207:           
208:           #ifdef	SPCSIGN
209:           #define	putsign()	pputc(flag & SPCSIGN ? '-' : '+')
210:           #else
211:           #define	putsign()	pputc('-')
212:           #endif	// SPCSIGN
213:           
214:           // were there ANY % formats defined?
215:           #if	defined(FLOATFORMAT) || defined(TEN) || defined(EIGHT) || defined(SIXTEEN) || \
216:           	defined(CHAR) || defined(POINTER) || defined(STRING) || defined(UNSIGN) || defined(PERCPERC)
217:           #define	ANYFORMAT
218:           #else
219:           #undef	ANYFORMAT
220:           #endif
221:           
222:           #ifdef	CHAR
223:           #ifndef	PERCPERC
224:           #define	PERCPERC
225:           #endif
226:           #endif
227:           
228:           #if	!defined(PRINTF) && !defined(VPRINTF) && !defined(SPRINTF) && !defined(VSPRINTF)
229:           #error	Must define at least one of PRINTF SPRINTF or VSPRINTF
230:           #endif
231:           
232:           #if	i8086 && SMALL_DATA
233:           #define	CONST	far
234:           #else
235:           #define	CONST	const
236:           #endif
237:           
238:            /* we don't need plus signs, use minus signs only if we have floats or signed ints */
239:           
240:           #if	!defined(NEGSIGN) && defined(TEN)
241:           #define	NEGSIGN	0x03
242:           #endif
243:           
244:           #ifndef	RETVALUE
245:           #define	INCR_CNT	/*nix */
246:           #else
247:           #define	INCR_CNT	,(++ccnt)
248:           #endif
249:           
250:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT) || defined(ALTERN) || defined(DEFPREC) || defined(POINTER)
251:           #define	FLAG_SIZE	unsigned short
252:           #else
253:           #define	FLAG_SIZE	unsigned char
254:           #endif
255:           
256:           
257:           #if	(sizeof(long) == sizeof(int) || defined(__FLOAT)) && !defined(__LONG)
258:           #define	__LONG	1
259:           #endif
260:           
261:           #if	sizeof(double) == sizeof(long) && DBL_MAX_EXP == 128
262:           #undef	frexp
263:           #define	frexp(val, ptr) (void)(*(ptr) = (unsigned char)((*(unsigned long *)&val >> 23) & 255) - 126)
264:           #elif	defined(_PSOC_)
265:           #undef	frexp
266:           #define	frexp(val, ptr) (void)(*(ptr) = ((unsigned char)(*(unsigned short long *)&val >> 15)) - 126)
267:           #elif	sizeof(double) == 3 && DBL_MAX_EXP == 128
268:           #undef	frexp
269:           #define	frexp(val, ptr) (void)(*(ptr) = ((*(unsigned long *)&val >> 15) & 255) - 126)
270:           #endif
271:           
272:           #if	defined(__FLOAT) && sizeof(double) == 8
273:           #define	DOUBLE	1
274:           
275:           extern double	_dto64i(double);
276:           extern double	_64itod(double);
277:           extern double	_div64(double, double);
278:           extern double	_divto64i(double, double);
279:           extern unsigned	_div64ir(double, double);
280:           extern unsigned	_mod64i10(double);
281:           
282:           #else
283:           #define	DOUBLE	0
284:           #endif
285:           
286:           #ifdef	__LONG
287:           #define	value	long
288:           #define	NDIG	12		/* max number of digits to be printed */
289:           #else
290:           #define	value	int
291:           #define	NDIG	6		/* max number of digits to be printed */
292:           #endif
293:           
294:           #if	DOUBLE
295:           union {
296:           	unsigned long	ul[40];
297:           	double		db[20];
298:           }	_fdp =
299:           {
300:           #if	!defined(BIG_ENDIAN) && !defined(LITTLE_ENDIAN)
301:           #error Neither BIG_ENDIAN or LITTLE_ENDIAN has been set
302:           #endif
303:           #if	BIG_ENDIAN
304:           	0x00000000,0x00000001,
305:           	0x00000000,0x0000000A,
306:           	0x00000000,0x00000064,
307:           	0x00000000,0x000003E8,
308:           	0x00000000,0x00002710,
309:           	0x00000000,0x000186A0,
310:           	0x00000000,0x000F4240,
311:           	0x00000000,0x00989680,
312:           	0x00000000,0x05F5E100,
313:           	0x00000000,0x3B9ACA00,
314:           	0x00000002,0x540BE400,
315:           	0x00000017,0x4876E800,
316:           	0x000000E8,0xD4A51000,
317:           	0x00000918,0x4E72A000,
318:           	0x00005AF3,0x107A4000,
319:           	0x00038D7E,0xA4C68000,
320:           	0x002386F2,0x6FC10000,
321:           	0x01634578,0x5D8A0000,
322:           	0x0DE0B6B3,0xA7640000,
323:           	0x8AC72304,0x89E80000,
324:           #else
325:           	0x00000001,0x00000000,
326:           	0x0000000A,0x00000000,
327:           	0x00000064,0x00000000,
328:           	0x000003E8,0x00000000,
329:           	0x00002710,0x00000000,
330:           	0x000186A0,0x00000000,
331:           	0x000F4240,0x00000000,
332:           	0x00989680,0x00000000,
333:           	0x05F5E100,0x00000000,
334:           	0x3B9ACA00,0x00000000,
335:           	0x540BE400,0x00000002,
336:           	0x4876E800,0x00000017,
337:           	0xD4A51000,0x000000E8,
338:           	0x4E72A000,0x00000918,
339:           	0x107A4000,0x00005AF3,
340:           	0xA4C68000,0x00038D7E,
341:           	0x6FC10000,0x002386F2,
342:           	0x5D8A0000,0x01634578,
343:           	0xA7640000,0x0DE0B6B3,
344:           	0x89E80000,0x8AC72304,
345:           #endif
346:           };
347:           
348:           #define	fdpowers	_fdp.db
349:           
350:           #else
351:           #define	fdpowers	dpowers
352:           #endif
353:           #if defined(TEN) || defined(__FLOAT) || defined (UNSIGN)
354:           const static unsigned value	dpowers[] =	{1, 10, 100, 1000, 10000,
355:           #ifdef	__LONG
356:           						 100000, 1000000, 10000000, 100000000,
357:           						 1000000000
358:           #endif
359:           							 };
360:           #endif
361:           #ifdef	SIXTEEN
362:           const static unsigned value	hexpowers[] =	{1, 0x10, 0x100, 0x1000,
363:           #if	__LONG
364:           						 0x10000, 0x100000, 0x1000000, 0x10000000
365:           #endif
366:           							};
367:           #endif
368:           #ifdef	EIGHT
369:           const static unsigned value	octpowers[] =	{1, 010, 0100, 01000, 010000, 0100000,
370:           #ifdef	__LONG
371:           						01000000,
372:           						 010000000, 0100000000, 01000000000, 010000000000,
373:           						 0100000000000
374:           #endif
375:           							};
376:           #endif
377:           
378:           #ifdef	__FLOAT
379:           
380:           #define	NDDIG	(sizeof fdpowers/sizeof fdpowers[0])
381:           
382:           #if	DBL_MAX_10_EXP > 120
383:           #define	expon	int
384:           #else
385:           #define	expon	signed char
386:           #endif
387:           
388:           extern const double	_powers_[], _npowers_[];
389:           #ifdef	z80
390:           #define	_div_to_l_(a, b)	((unsigned long)((a)/(b)))
391:           #else
392:           extern unsigned long	_div_to_l_(double, double);
393:           #ifdef	_OMNI_CODE_
394:           extern unsigned long	_tdiv_to_l_(float, float);
395:           #ifdef	_HTKC_
396:           #pragma callname _div_to_l_ double
397:           #pragma callname _tdiv_to_l_ float
398:           #endif
399:           #define	div_to_l_(a,b)	((sizeof(double)== 3) ? _tdiv_to_l_(a,b) : _div_to_l_(a,b))
400:           #else
401:           #define	div_to_l_	_div_to_l_
402:           #endif
403:           #endif
404:           
405:           /* this routine returns a value to round to the number of decimal
406:           	places specified */
407:           #if __FLOAT
408:           static double
409:           fround(unsigned char prec)
410:           {
411:           	/* prec is guaranteed to be less than NDIG */
412:           
413:           	if(prec>=110)
414:           		return 0.5 * _npowers_[prec/100+18] * _npowers_[(prec%100)/10+9] * _npowers_[prec%10];
415:           	else if(prec > 10)
416:           		return 0.5 * _npowers_[prec/10+9] * _npowers_[prec%10];
417:           	return 0.5 * _npowers_[prec];
418:           }
419:           #endif
420:           
421:           /* this routine returns a scaling factor equal to 1 to the decimal
422:              power supplied */
423:           
424:           static double
425:           scale(expon scl)
426:           {
427:           
428:           	if(scl < 0) {
429:           		scl = -scl;
430:           		if(scl>=110)
431:           			return _npowers_[scl/100+18] * _npowers_[(scl%100)/10+9] * _npowers_[scl%10];
432:           		else if(scl > 10)
433:           			return _npowers_[scl/10+9] * _npowers_[scl%10];
434:           		return _npowers_[scl];
435:           	}
436:           	if(scl>=110)
437:           		return _powers_[scl/100+18] * _powers_[(scl%100)/10+9] * _powers_[scl%10];
438:           	else if(scl > 10)
439:           		return _powers_[scl/10+9] * _powers_[scl%10];
440:           	return _powers_[scl];
441:           }
442:           
443:           
444:           #endif	/* __FLOAT */
445:           
446:           
447:           
448:           #ifdef	_HOSTED
449:           #define	pputc(c)	(putc(c, fp) != EOF && ++ccnt)
450:           int
451:           vfprintf(FILE * fp, register const  char * f, register va_list ap)
452:           {
453:           	char		cbuf[2];
454:           #else	/* _HOSTED */
455:           int
456:           #if	defined(VPRINTF) || (defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF)))
457:           #define	pputc(c)	if(pb->func) (pb->func(c))INCR_CNT; else ((*pb->ptr++ = c)INCR_CNT)
458:           _doprnt(struct __prbuf * pb, register const  char * f, register va_list ap)
459:           {
460:           #endif
461:           
462:           #if	defined(PRINTF) && !(defined(SPRINTF) || defined(VSPRINTF))
463:           #define	pputc(c)	(putch(c) INCR_CNT)
464:           printf(const char * f, ...)
465:           {
466:           	va_list	ap;
467:           #define	NEED_START
468:           #endif
469:           
470:           #if	!defined(PRINTF) && defined(VSPRINTF)
471:           
472:           #ifdef	SPRINTF
473:           sprintf(char * sp, const char * f, ...)
474:           {
475:           	va_list	ap;
476:           
477:           	va_start(ap, f);
478:           	vsprintf(sp, f, ap);
479:           	va_end(ap);
480:           }
481:           int
482:           #endif	// SPRINTF
483:           
484:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
485:           vsprintf(char * sp, register const  char * f, register va_list ap)
486:           {
487:           #define NEED_START
488:           #endif	// VSPRINTF
489:           
490:           #if	!defined(PRINTF) && defined(SPRINTF) && !defined(VSPRINTF)
491:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
492:           sprintf(char * sp, const  char * f, ...)
493:           {
494:           	va_list	ap;
495:           #define	NEED_START
496:           #endif
497:           #endif	// HOSTED
498:           
499:           	signed char		c;
500:           #if	defined(WIDTH) || defined(__FLOAT)
501:           	int		width;
502:           #endif
503:           #ifdef	__LONG
504:           	int		prec;
505:           #else
506:           	signed char	prec;
507:           #endif
508:           	FLAG_SIZE	flag;
509:           #ifdef	RETVALUE
510:           	int		ccnt = 0;
511:           #else
512:           #define	ccnt	0
513:           #endif
514:           #ifdef	__FLOAT
515:           	char	d;
516:           	double	fval; 
517:           	int		exp;
518:           #if DOUBLE
519:           	double		ival;
520:           #endif
521:           #endif
522:           #if ! DOUBLE || __FLOAT
523:           	union {
524:           		unsigned long vd;
525:           		double integ;
526:           	} tmpval;
527:           #endif
528:           	unsigned value	val;
529:           	unsigned	len;
530:           	CONST char *	cp;
531:           	
532:           #ifdef	NEED_START
533:           	va_start(ap, f);
0880  3025     MOVLW 0x25
0881  00AB     MOVWF stereo
534:           #endif
535:           
536:           	while(c = *f++) {
0882  0020     MOVLB 0x0
0883  0824     MOVF n, W
0884  00A8     MOVWF 0x28
0885  0823     MOVF f, W
0886  00A7     MOVWF 0x27
0887  0AA3     INCF f, F
0888  1903     BTFSC STATUS, 0x2
0889  0AA4     INCF n, F
088A  0084     MOVWF FSR0
088B  0828     MOVF 0x28, W
088C  0085     MOVWF FSR0H
088D  0800     MOVF INDF0, W
088E  00B3     MOVWF r
088F  0833     MOVF r, W
0890  1903     BTFSC STATUS, 0x2
0891  0008     RETURN
0980  2882     GOTO 0x82
537:           #ifdef	ANYFORMAT
538:           		if(c != '%')
0892  3A25     XORLW 0x25
0893  1903     BTFSC STATUS, 0x2
0894  2899     GOTO 0x99
539:           #endif	//ANYFORMAT
540:           		{
541:           			pputc(c);
0895  0833     MOVF r, W
0896  2182     CALL 0x182
0897  3188     MOVLP 0x8
542:           			continue;
0898  2882     GOTO 0x82
543:           		}
544:           #ifdef	ANYFORMAT
545:           #ifdef	WIDTH
546:           		width = 0;
0899  01B1     CLRF width
089A  01B2     CLRF c
547:           #endif
548:           		flag = 0;
089B  01AC     CLRF flag
089C  28A1     GOTO 0xA1
549:           #if	defined(LEFT) || defined(SPCSIGN) || defined(MANSIGN) || defined(ALTERN) || defined(FILL)
550:           		for(;;) {
551:           			switch(*f) {
08A1  0823     MOVF f, W
08A2  0084     MOVWF FSR0
08A3  0824     MOVF n, W
08A4  0085     MOVWF FSR0H
08A5  0800     MOVF INDF0, W
08A6  3A30     XORLW 0x30
08A7  1903     BTFSC STATUS, 0x2
08A8  289D     GOTO 0x9D
08A9  28AA     GOTO 0xAA
552:           #ifdef	LEFT
553:           			case '-':
554:           				flag |= LEFT;
555:           				f++;
556:           				continue;
557:           #endif
558:           
559:           #ifdef	SPCSIGN
560:           			case ' ':
561:           				flag |= SPCSIGN;
562:           				f++;
563:           				continue;
564:           #endif
565:           
566:           #ifdef	MANSIGN
567:           			case '+':
568:           				flag |= MANSIGN;
569:           				f++;
570:           				continue;
571:           #endif
572:           #ifdef	ALTERN
573:           			case '#':
574:           				flag |= ALTERN;
575:           				f++;
576:           				continue;
577:           #endif
578:           #ifdef	FILL
579:           			case '0':
580:           				flag |= FILL;
089D  152C     BSF flag, 0x2
581:           				f++;
089E  0AA3     INCF f, F
089F  1903     BTFSC STATUS, 0x2
08A0  0AA4     INCF n, F
582:           				continue;
583:           #endif
584:           			}
585:           			break;
586:           		}
587:           #endif
588:           #if	defined(MANSIGN) && defined(SPCSIGN)
589:           		if(flag & MANSIGN)
590:           			flag &= ~SPCSIGN;
591:           #endif
592:           #if	defined(LEFT) && defined(FILL)
593:           		if(flag & LEFT)
594:           			flag &= ~FILL;
595:           #endif
596:           #ifdef	WIDTH
597:           		if(isdigit((unsigned)*f)) {
08AA  0823     MOVF f, W
08AB  0084     MOVWF FSR0
08AC  0824     MOVF n, W
08AD  0085     MOVWF FSR0H
08AE  0800     MOVF INDF0, W
08AF  2186     CALL 0x186
08B0  3188     MOVLP 0x8
08B1  1C03     BTFSS STATUS, 0x0
08B2  28DE     GOTO 0xDE
598:           			width = 0;
08B3  01B1     CLRF width
08B4  01B2     CLRF c
599:           			do {
600:           				width *= 10;
08B5  300A     MOVLW 0xA
08B6  00F3     MOVWF state
08B7  01F4     CLRF stereo
08B8  0832     MOVF c, W
08B9  00F6     MOVWF 0x76
08BA  0831     MOVF width, W
08BB  00F5     MOVWF s
08BC  3184     MOVLP 0x4
08BD  2410     CALL 0x410
08BE  3188     MOVLP 0x8
08BF  0874     MOVF stereo, W
08C0  00B2     MOVWF c
08C1  0873     MOVF state, W
08C2  00B1     MOVWF width
601:           			   	width += *f++ - '0';
08C3  0823     MOVF f, W
08C4  0084     MOVWF FSR0
08C5  0824     MOVF n, W
08C6  0085     MOVWF FSR0H
08C7  0800     MOVF INDF0, W
08C8  3ED0     ADDLW 0xD0
08C9  00A7     MOVWF 0x27
08CA  30FF     MOVLW 0xFF
08CB  1803     BTFSC STATUS, 0x0
08CC  3000     MOVLW 0x0
08CD  00A8     MOVWF 0x28
08CE  0827     MOVF 0x27, W
08CF  07B1     ADDWF width, F
08D0  0828     MOVF 0x28, W
08D1  3DB2     ADDWFC c, F
08D2  0AA3     INCF f, F
08D3  1903     BTFSC STATUS, 0x2
08D4  0AA4     INCF n, F
602:           			} while(isdigit((unsigned)*f));
08D5  0823     MOVF f, W
08D6  0084     MOVWF FSR0
08D7  0824     MOVF n, W
08D8  0085     MOVWF FSR0H
08D9  0800     MOVF INDF0, W
08DA  2186     CALL 0x186
08DB  3188     MOVLP 0x8
08DC  1803     BTFSC STATUS, 0x0
08DD  28B5     GOTO 0xB5
603:           #ifdef	STAR
604:           		} else if(*f == '*') {
605:           			width = va_arg(ap, int);
606:           			f++;
607:           #endif
608:           		}
609:           #endif
610:           #ifdef	PRECISION
611:           		if(*f == '.') {
612:           			flag |= PRECISION;
613:           			f++;
614:           #ifdef	STAR
615:           			if(*f == '*') {
616:           				prec = va_arg(ap, int);
617:           				f++;
618:           			} else
619:           #endif
620:           			{
621:           				prec = 0;
622:           				while(isdigit((unsigned)*f))
623:           					prec = prec*10 + *f++ - '0';
624:           			}
625:           		} else {
626:           			prec = 0;
627:           #ifdef	DEFPREC
628:           			flag |= DEFPREC;
629:           #endif	// DEFPREC
630:           		}
631:           #endif	// PRECISION
632:           #if	defined(__LONG) && defined(LONG)
633:           loop:
634:           #endif
635:           		switch(c = *f++) {
08DE  0824     MOVF n, W
08DF  00A8     MOVWF 0x28
08E0  0823     MOVF f, W
08E1  00A7     MOVWF 0x27
08E2  0AA3     INCF f, F
08E3  1903     BTFSC STATUS, 0x2
08E4  0AA4     INCF n, F
08E5  0084     MOVWF FSR0
08E6  0828     MOVF 0x28, W
08E7  0085     MOVWF FSR0H
08E8  0800     MOVF INDF0, W
08E9  00B3     MOVWF r
08EA  3A00     XORLW 0x0
08EB  1903     BTFSC STATUS, 0x2
08EC  2981     GOTO 0x181
08ED  3A78     XORLW 0x78
08EE  1903     BTFSC STATUS, 0x2
08EF  28F1     GOTO 0xF1
08F0  2882     GOTO 0x82
636:           
637:           		case 0:
638:           			goto alldone;
639:           
640:           #ifdef	LONG
641:           		case 'l':
642:           #ifdef	__LONG
643:           			flag |= LONG;
644:           			goto loop;
645:           #else
646:           			cp = "(non-long printf)";
647:           			goto strings;
648:           #endif
649:           #endif
650:           
651:           #ifdef	FLOATFORMAT
652:           #ifndef	__FLOAT
653:           		case 'E':
654:           		case 'f':
655:           		case 'e':
656:           		case 'G':
657:           		case 'g':
658:           			cp = "(non-float printf)";
659:           			goto strings;
660:           #else
661:           #ifdef	FFMT
662:           		case 'f':
663:           			flag |= FFMT;
664:           			break;
665:           #endif
666:           
667:           #ifdef	EFMT
668:           #ifdef	UPCASE
669:           		case 'E':
670:           			flag |= UPCASE;
671:           #endif
672:           		case 'e':
673:           			flag |= EFMT;
674:           			break;
675:           #endif
676:           
677:           #ifdef	GFMT
678:           #ifdef	UPCASE
679:           		case 'G':
680:           			flag |= UPCASE;
681:           #endif
682:           		case 'g':
683:           			flag |= GFMT;
684:           			break;
685:           #endif	// GFMT
686:           #endif
687:           #endif	// FLOATFORMAT
688:           #ifdef	EIGHT
689:           		case 'o':
690:           #ifdef	MULTRAD
691:           			flag |= EIGHT;
692:           #endif
693:           			break;
694:           #endif
695:           
696:           #ifdef	TEN
697:           		case 'd':
698:           		case 'i':
699:           			break;
700:           #endif
701:           
702:           #ifdef	POINTER
703:           		case 'p':
704:           #if	i8086 && LARGE_DATA
705:           			flag |= LONG;
706:           #elif	_PIC18
707:           			flag |= POINTER;
708:           #endif
709:           #endif	// POINTER
710:           #ifdef	SIXTEEN
711:           #ifdef	HEXUPCASE
712:           		case 'X':
713:           #ifdef	UPCASE
714:           			flag |= UPCASE;
715:           #endif
716:           #endif
717:           #if	defined(HEXLOWCASE) || !defined(UPCASE)
718:           		case 'x':
719:           #endif
720:           #ifdef	MULTRAD
721:           			flag |= SIXTEEN;
722:           #endif
723:           			break;
724:           #endif	// SIXTEEN
725:           
726:           #if	defined(STRING) || defined(PERCPERC)
727:           #ifdef	STRING
728:           		case 's':
729:           #if	i8086 && SMALL_DATA
730:           			if(flag & LONG)
731:           				cp = va_arg(ap, far char *);
732:           			else
733:           #endif
734:           				cp = va_arg(ap, const char *);
735:           #endif	// STRING
736:           #if	!defined(__FLOAT) && !defined(CUSTOM_PRINTF)
737:           strings:
738:           #endif
739:           #ifdef	STRING
740:           			if(!cp)
741:           				cp = "(null)";
742:           #endif
743:           #if	defined(WIDTH) || defined(PRECISION)
744:           #if	defined(STRING)
745:           			len = 0;
746:           			while(cp[len])
747:           				len++;
748:           #endif
749:           #ifdef	PERCPERC
750:           dostring:
751:           #endif
752:           #ifdef	PRECISION
753:           			if(prec && prec < len)
754:           				len = prec;
755:           #endif	// PRECISION
756:           #ifdef	WIDTH
757:           			if(width > len)
758:           				width -= len;
759:           			else
760:           				width = 0;
761:           #ifdef	LEFT
762:           			if(!(flag & LEFT))
763:           #endif	// LEFT
764:           				while(width--)
765:           					pputc(' ');
766:           #endif	// WIDTH
767:           			while(len--)
768:           				pputc(*cp++);
769:           #ifdef	LEFT
770:           			if(flag & LEFT)
771:           				while(width--)
772:           					pputc(' ');
773:           #endif	// LEFT
774:           			continue;
775:           #else	// WIDTH || PRECISION
776:           #if	defined(STRING)
777:           			while(*cp)
778:           				pputc(*cp++);
779:           			continue;
780:           #endif
781:           #endif	// WIDTH || PRECISION
782:           #endif	// defined(STRING) || defined(PERCPERC)
783:           #ifdef	CHAR
784:           		case 'c':
785:           #if	_HOSTED
786:           			val = va_arg(ap, int);
787:           			c = val >> 8;
788:           			if(flag & LONG && c && (unsigned char)c != 0xFF) {
789:           				cbuf[0] = c;
790:           				cbuf[1] = val;
791:           				len = 2;
792:           			} else {
793:           				cbuf[0] = val;
794:           				len = 1;
795:           			}
796:           			cp = cbuf;
797:           			goto dostring;
798:           #else
799:           			c = va_arg(ap, int);
800:           #endif	// _HOSTED
801:           #endif	// CHAR
802:           		default:
803:           #ifdef	PERCPERC
804:           #if	defined(WIDTH) || defined(PRECISION)
805:           			cp = (char *)&c;
806:           			len = 1;
807:           			goto dostring;
808:           #else
809:           			pputc(c);
810:           			continue;
811:           #endif
812:           #else	// PERCPERC
813:           			continue;
814:           #endif
815:           
816:           #ifdef	UNSIGN
817:           		case 'u':
818:           			flag |= UNSIGN;
819:           			break;
820:           #endif
821:           
822:           		}
823:           #endif	// ANYFORMAT
824:           #ifdef	__FLOAT
825:           		if(flag & (FLOATFORMAT)) {
826:           #ifdef	DEFPREC
827:           			if(flag & DEFPREC)
828:           #endif
829:           				prec = 6;
830:           			fval = va_arg(ap, double);	// source the floating point value
831:           			if(fval < 0.0) {
832:           				fval = -fval;		// get the absolute value
833:           				flag |= NEGSIGN;
834:           			}
835:           			exp = 0;		/* If the number is zero, the exponent is zero. */
836:           			if( fval!=0) {		/* If the number is non-zero, find the exponent. */
837:           				frexp(fval, &exp);		/* get binary exponent */
838:           				exp--;				/* adjust 0.5 -> 1.0 */
839:           				exp *= 3;
840:           				exp /= 10;			/* estimate decimal exponent */
841:           				if(exp < 0)
842:           					exp--;
843:           				// the following line can cause "recursive call" errors because scale calls
844:           				// ftmul, and is used when evaluating an argument to ftmul
845:           				//integ = fval * scale(-exp);
846:           				tmpval.integ = scale(-exp);		// replaced with this
847:           				tmpval.integ *= fval;
848:           				if(tmpval.integ < 1.0)
849:           					exp--;
850:           				else if(tmpval.integ >= 10.0)
851:           					exp++;
852:           			}
853:           #if	defined(EFMT) || defined(GFMT)
854:           			if(exp <= 0)	// value is 0.??? (neg expnt) whole characters = 1 (allow zero)
855:           				c = 1;
856:           			else
857:           				c = exp;
858:           			if(
859:           #ifdef	EFMT
860:           					flag & EFMT
861:           #ifdef	GFMT
862:           					||
863:           #endif
864:           #endif
865:           #ifdef	GFMT
866:           					flag & GFMT && (exp < -4 || exp >= (int)prec)
867:           #endif
868:           				) {	/* use e format */
869:           #ifdef	GFMT
870:           				if(prec && flag & GFMT)
871:           					prec--;		/* g format precision includes integer digit */
872:           #endif
873:           				if((unsigned)prec > NDDIG - 2)
874:           					c = NDDIG - 2;
875:           				else
876:           					c = prec;
877:           				if( fval!=0) {	/* Normalise only if the number is non-zero. */
878:           					fval /= scale(exp-c);
879:           #if	DOUBLE
880:           					ival = _dto64i(fval);
881:           					if(fval - _64itod(ival) >= 0.5) {
882:           						fval += 0.5;
883:           						ival = _dto64i(fval);
884:           					}
885:           					if(ival >= fdpowers[c+1]) {
886:           						fval *= 1e-1;
887:           						exp++;
888:           					} else if(ival < fdpowers[c]) {
889:           						fval *= 10.0;
890:           						exp--;
891:           					}
892:           #else	
893:           					if(fval - (double)(unsigned long)fval >= 0.5)
894:           						fval += 0.5;
895:           					if((unsigned long)fval >= fdpowers[c+1]) {
896:           						fval *= 1e-1;
897:           						exp++;
898:           					} else if((unsigned long)fval < fdpowers[c]) {
899:           						fval *= 10.0;
900:           						exp--;
901:           					}
902:           #endif
903:           				}
904:           #if defined(GFMT) && defined(ALTERN)
905:           				if(flag & GFMT && !(flag & ALTERN)) {		/* g format, precision means something different */
906:           					if(prec > (int)(NDDIG))
907:           						prec = NDDIG;
908:           #if	DOUBLE
909:           					ival = _dto64i(fval);
910:           					while(ival != 0.0 && _mod64i10(ival) == 0) {
911:           						prec--;
912:           						ival = _div64(ival, fdpowers[1]);
913:           					}
914:           #else
915:           					val = (unsigned long)fval;
916:           					while(val && val % 10 == 0) {
917:           						prec--;
918:           						val /= 10;
919:           					}
920:           #endif
921:           					if(prec < c) {
922:           						fval /= scale(c-prec);
923:           						c = prec;
924:           					}
925:           
926:           				}
927:           #endif
928:           #ifdef	WIDTH
929:           				width -=  prec + 5;
930:           #ifdef	ALTERN
931:           				if(prec || flag & ALTERN)
932:           					width--;
933:           #endif
934:           				if(flag & NEGSIGN)
935:           					width--;
936:           #if	DBL_MAX_10_EXP >= 100
937:           #if	DBL_MAX_10_EXP >= 1000
938:           				if(exp >= 1000 || exp <= -1000)	/* 4 digit exponent */
939:           					width--;
940:           #endif
941:           				if(exp >= 100 || exp <= -100)	/* 3 digit exponent */
942:           					width--;
943:           #endif
944:           #endif	// WIDTH
945:           #ifdef	FILL
946:           				if(flag & FILL) {
947:           #if defined(MANSIGN) && defined(SPCSIGN)
948:           					if(flag & MANSIGN)
949:           						pputc(flag & SPCSIGN ? '-' : '+');
950:           					else if(flag & SPCSIGN)
951:           						pputc(' ');
952:           #endif
953:           					while(width > 0) {
954:           						pputc('0');
955:           						width--;
956:           					}
957:           				} else
958:           #endif	// FILL
959:           				{
960:           #ifdef	WIDTH
961:           #ifdef	LEFT
962:           					if(!(flag & LEFT))
963:           #endif
964:           						while(width > 0) {
965:           							pputc(' ');
966:           							width--;
967:           						}
968:           #endif	// WIDTH
969:           #ifdef	MANSIGN
970:           					if(flag & MANSIGN)
971:           						putsign();
972:           #else
973:           					if(flag & NEGSIGN)
974:           						pputc('-');
975:           #endif	// MANSIGN
976:           #ifdef	SPCSIGN
977:           					else if(flag & SPCSIGN)
978:           						pputc(' ');
979:           #endif	// SPCSIGN
980:           				}
981:           #if	DOUBLE
982:           				ival = _dto64i(fval);
983:           				pputc(_div64ir(ival, fdpowers[c]) + '0');
984:           #else
985:           				val = (unsigned long)fval;
986:           				pputc(val/dpowers[c] + '0');
987:           				val %= dpowers[c];
988:           #endif
989:           #ifdef	ALTERN
990:           				if(prec || flag & ALTERN)
991:           #else
992:           				if(prec)
993:           #endif
994:           				{
995:           					pputc('.');
996:           					prec -= c;
997:           					while(c--) {
998:           #if	DOUBLE
999:           						pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1000:          #else
1001:          #ifdef	GFMT
1002:          						if(flag & GFMT && val == 0) {
1003:          							prec = c = 0;
1004:          							break;
1005:          						}
1006:          #endif
1007:          						pputc('0' + (val/dpowers[c]));
1008:          						val %= dpowers[c];
1009:          #endif
1010:          					}
1011:          					while(prec) {
1012:          						pputc('0');
1013:          						prec--;
1014:          					}
1015:          				}
1016:          #ifdef	UPCASE
1017:          				if(flag & UPCASE)
1018:          					pputc('E');
1019:          				else
1020:          #endif
1021:          					pputc('e');
1022:          				if(exp < 0) {
1023:          					exp = -exp;
1024:          					pputc('-');
1025:          				} else
1026:          					pputc('+');
1027:          #if	DBL_MAX_10_EXP >= 100
1028:          #if	DBL_MAX_10_EXP >= 1000
1029:          				if(exp >= 1000) {
1030:          					pputc(exp / 1000 + '0');
1031:          					exp %= 1000;
1032:          				}
1033:          #endif
1034:          				if(exp >= 100) {
1035:          					pputc(exp / 100 + '0');
1036:          					exp %= 100;
1037:          				}
1038:          #endif
1039:          				pputc(exp / 10 + '0');
1040:          				pputc(exp % 10 + '0');
1041:          #ifdef	LEFT
1042:          				if((flag & LEFT) && width > 0)
1043:          					do
1044:          						pputc(' ');
1045:          					while(--width);
1046:          #endif	// LEFT
1047:          					continue;
1048:          				}
1049:          #endif	// EFMT || GFMT
1050:          				/* here for f format */
1051:          #if	DOUBLE
1052:          #ifdef	GFMT
1053:          				if(flag & GFMT) {
1054:          					if(exp < 0)	// fractional part only
1055:          						prec -= exp-1;
1056:          					ival = _dto64i(fval);
1057:          					for(c = 1 ; c != NDDIG ; c++)
1058:          						if(ival < fdpowers[c])
1059:          							break;
1060:          					if(prec > NDDIG)
1061:          						prec = NDDIG;
1062:          					prec -= c;
1063:          					ival = _dto64i((fval - _64itod(ival)) * scale(prec)+0.5);
1064:          					// see how many zeros are at the end of the fractional part
1065:          					while(prec && _mod64i10(ival) == 0) {
1066:          						prec--;
1067:          						ival = _div64(ival, fdpowers[1]);
1068:          					}
1069:          				}
1070:          #endif	// GFMT
1071:          				if(prec <= (int)NDDIG)
1072:          					fval += fround(prec);
1073:          				if(exp > (int)(NDDIG)-2) {
1074:          					exp -= NDDIG-2;
1075:          					ival = _divto64i(fval, scale(exp));
1076:          					fval = 0.0;
1077:          				} else {
1078:          					ival = _dto64i(fval);
1079:          					fval -= _64itod(ival);
1080:          					exp = 0;
1081:          				}
1082:          				for(c = 1 ; c != NDDIG ; c++)
1083:          					if(ival < fdpowers[c])
1084:          						break;
1085:          #else	// DOUBLE
1086:          #ifdef	GFMT
1087:          				if(flag & GFMT) {
1088:          					if(exp < 0)	// fractional part only
1089:          						prec -= (exp+1);
1090:          					// count number of digits in the integral part (this is for %g)
1091:          					val = (unsigned long)fval;
1092:          					for(c = 0 ; c != NDDIG ; c++)
1093:          						if(val < fdpowers[c])
1094:          							break;
1095:          					prec -= c;		// reduce precision by this
1096:          					if(prec <= NDIG)
1097:          						fval += fround(prec);
1098:          					// get fractional part and count trailing zeros - reduce
1099:          					// prec as required
1100:          					{
1101:          						double	temp;
1102:          						temp = scale(prec);
1103:          						temp *= fval - (double)val;
1104:          						val = (unsigned long)temp;
1105:          					}
1106:          					while(prec && val % 10 == 0) {
1107:          						val /= 10;
1108:          						prec--;
1109:          					}
1110:          				} else
1111:          #endif	//GFMT
1112:          					if(prec <= NDIG)
1113:          						fval += fround(prec);
1114:          
1115:          				/* ~4.2e9 is the largest float that will fit into a 32-bit long */
1116:          				if((exp > 9)||(fval != 0 && (unsigned long)fval == 0 && exp > 1)) {
1117:          					// fval is > 4.2e9
1118:          					// new exp must be such that div_to_l() is < 4.2e9
1119:          					// OLD CODE:	if(fval / scale(exp) < 4.294967296){
1120:          					if(tmpval.integ < 4.294967296){
1121:          						exp -= NDDIG-1;
1122:          					}else{
1123:          						exp -= NDDIG-2;
1124:          					}
1125:          					tmpval.integ = scale(exp);
1126:          					val = div_to_l_(fval, tmpval.integ);
1127:           					//val = _div_to_l_(integ, fval);
1128:          					//val = (long)(integ * fval);	// fit as much signifigant data into the long as it can hold
1129:          					fval = 0.0;	// There will be no fractional component
1130:          				} else {
1131:          					val = (unsigned long)fval;
1132:          					fval -= (double)val;
1133:          					exp = 0;
1134:          				}
1135:          				// count digits in integral part
1136:          				for(c = 1 ; c != NDDIG ; c++)
1137:          					if(val < fdpowers[c])
1138:          						break;
1139:          #endif	// DOUBLE
1140:          #ifdef	WIDTH
1141:          				// at this point, c contains the number of whole-number digits to print
1142:          				width -= prec + c + exp;
1143:          				if(
1144:          #ifdef	ALTERN
1145:          						flag & ALTERN ||
1146:          #endif
1147:          						prec)
1148:          					width--;		// allow for decimal point
1149:          				if(flag & NEGSIGN)
1150:          					width--;
1151:          #endif	// WIDTH
1152:          #ifdef	FILL
1153:          				if(flag & FILL) {
1154:          #ifdef	MANSIGN
1155:          					if(flag & MANSIGN)
1156:          #else
1157:          					if(flag & NEGSIGN)
1158:          #endif	// MANSIGN
1159:          						putsign();
1160:          #if defined(MANSIGN) && defined(SPCSIGN)
1161:          					else
1162:          #endif
1163:          #ifdef	SPCSIGN
1164:          					if(flag & SPCSIGN)
1165:          						pputc(' ');
1166:          #endif	// SPCSIGN
1167:          #ifdef	WIDTH
1168:          					while(width > 0) {
1169:          						pputc('0');
1170:          						width--;
1171:          					}
1172:          #endif	// WIDTH
1173:          				} else
1174:          #endif	// FILL
1175:          				{
1176:          #ifdef	LEFT
1177:          					if(!(flag & LEFT))
1178:          #endif
1179:          #ifdef	WIDTH
1180:          					while(width > 0) {
1181:          						pputc(' ');
1182:          						width--;
1183:          					}
1184:          #endif	// WIDTH
1185:          #ifdef	MANSIGN
1186:          				if(flag & MANSIGN)
1187:          #else
1188:          				if(flag & NEGSIGN)
1189:          #endif	// MANSIGN
1190:          					putsign();
1191:          #ifdef	SPCSIGN
1192:          				else if(flag & SPCSIGN)
1193:          					pputc(' ');
1194:          #endif	// SPCSIGN
1195:          			}
1196:          			while(c--) {
1197:          #if	DOUBLE
1198:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1199:          #else
1200:          				{
1201:          					tmpval.vd = val/dpowers[c];
1202:          					tmpval.vd %= 10;
1203:          					pputc('0' + tmpval.vd);
1204:          				}
1205:          #endif	// DOUBLE
1206:          			}
1207:          			while(exp > 0) {
1208:          				pputc('0');
1209:          				exp--;
1210:          			}
1211:          			if(prec > (int)(NDDIG-2))
1212:          				c = NDDIG-2;
1213:          			else
1214:          				c = prec;
1215:          			prec -= c;
1216:          #ifdef	ALTERN
1217:          			if(c || flag & ALTERN)
1218:          #else
1219:          			if(c)
1220:          #endif
1221:          				pputc('.');
1222:          #if	DOUBLE
1223:          			ival = _dto64i(fval * scale(c));
1224:          			while(c)
1225:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[--c])));
1226:          #else	// DOUBLE
1227:          			val = (long)(fval * scale(c));
1228:          			while(c--) {
1229:          				tmpval.vd = val/dpowers[c];
1230:          				tmpval.vd %= 10;
1231:          				pputc('0' + tmpval.vd);
1232:          				val %= dpowers[c];
1233:          			}
1234:          #endif	// DOUBLE
1235:          			while(prec) {
1236:          				pputc('0');
1237:          				prec--;
1238:          			}
1239:          #ifdef	LEFT
1240:          			if((flag & LEFT) && width > 0)
1241:          				do
1242:          					pputc(' ');
1243:          				while(--width);
1244:          #endif
1245:          			continue;
1246:          		}
1247:          #endif	/* __FLOAT */
1248:          
1249:          #if	defined(TEN)
1250:          #ifdef	BASEM
1251:          		if((flag & BASEM) == TEN)
1252:          #endif	//BASEM
1253:          		{
1254:          #ifdef	LONG
1255:          			if(flag & LONG)
1256:          				val = va_arg(ap, long);
1257:          			else
1258:          #endif	// LONG
1259:          				val = (value)va_arg(ap, int);
1260:          #ifdef	NEGSIGN
1261:          			if((value)val < 0) {
1262:          				flag |= NEGSIGN;
1263:          				val = -val;
1264:          			}
1265:          #endif
1266:          		}
1267:          #ifdef	BASEM
1268:          		else
1269:          #endif
1270:          #endif	// TEN
1271:          
1272:          #if	defined(EIGHT) || defined(SIXTEEN) || defined(UNSIGN)
1273:          		{
1274:          #ifdef	__LONG
1275:          #if	defined(_PIC18) && defined(POINTER)
1276:          			if(flag & POINTER)
1277:          				val = (unsigned long)va_arg(ap, far char *);
1278:          			else
1279:          #endif
1280:          #ifdef	LONG
1281:          				if(flag & LONG)
1282:          				val = va_arg(ap, unsigned long);
1283:          			else
1284:          #endif	// LONG
1285:          #endif	// __LONG
1286:          				val = va_arg(ap, unsigned);
08F1  082B     MOVF i, W
08F2  0086     MOVWF FSR1
08F3  0187     CLRF FSR1H
08F4  3F40     MOVIW [0]FSR1
08F5  00AE     MOVWF val
08F6  3F41     MOVIW [1]FSR1
08F7  00AF     MOVWF 0x2F
08F8  0AAB     INCF i, F
08F9  0AAB     INCF i, F
1287:          		}
1288:          #endif	// EIGHT or SIXTEEN or UNSIGN
1289:          #ifdef	PRECISION
1290:          		if(prec == 0 && val == 0)
1291:          			prec++;
1292:          #endif
1293:          #ifdef	MULTRAD
1294:          		switch((unsigned char)(flag & BASEM)) {
1295:          #endif
1296:          #if	defined(TEN) || defined(UNSIGN)
1297:          #ifdef	MULTRAD
1298:          #ifdef	TEN
1299:          		case TEN:
1300:          #endif
1301:          #ifdef	UNSIGN
1302:          		case UNSIGN:
1303:          #endif
1304:          #endif	// MULTRAD
1305:          			for(c = 1 ; c != sizeof dpowers/sizeof dpowers[0] ; c++)
1306:          				if(val < dpowers[c])
1307:          					break;
1308:          #ifdef	MULTRAD
1309:          			break;
1310:          #endif
1311:          #endif	// TEN || UNSIGN
1312:          #ifdef	SIXTEEN
1313:          #ifdef	MULTRAD
1314:          		case SIXTEEN:
1315:          #endif	// MULTRAD
1316:          			for(c = 1 ; c != sizeof hexpowers/sizeof hexpowers[0] ; c++)
08FA  01B3     CLRF r
08FB  0AB3     INCF r, F
0912  3004     MOVLW 0x4
0913  0AB3     INCF r, F
0914  0633     XORWF r, W
0915  1D03     BTFSS STATUS, 0x2
0916  28FC     GOTO 0xFC
1317:          				if(val < hexpowers[c])
08FC  0833     MOVF r, W
08FD  00A7     MOVWF 0x27
08FE  3000     MOVLW 0x0
08FF  01A8     CLRF 0x28
0900  35A7     LSLF 0x27, F
0901  0DA8     RLF 0x28, F
0902  0727     ADDWF 0x27, W
0903  0084     MOVWF FSR0
0904  3090     MOVLW 0x90
0905  3D28     ADDWFC 0x28, W
0906  0085     MOVWF FSR0H
0907  3F00     MOVIW [0]FSR0
0908  00A9     MOVWF r
0909  3F01     MOVIW [1]FSR0
090A  00AA     MOVWF p
090B  022F     SUBWF 0x2F, W
090C  1D03     BTFSS STATUS, 0x2
090D  2910     GOTO 0x110
090E  0829     MOVF r, W
090F  022E     SUBWF val, W
0910  1C03     BTFSS STATUS, 0x0
0911  2917     GOTO 0x117
1318:          					break;
1319:          #ifdef	MULTRAD
1320:          			break;
1321:          #endif
1322:          #endif
1323:          
1324:          #ifdef	EIGHT
1325:          #ifdef	MULTRAD
1326:          		case EIGHT:
1327:          #endif	// MULTRAD
1328:          			for(c = 1 ; c != sizeof octpowers/sizeof octpowers[0] ; c++)
1329:          				if(val < octpowers[c])
1330:          					break;
1331:          #ifdef	MULTRAD
1332:          			break;
1333:          #endif
1334:          #endif
1335:          #ifdef	MULTRAD
1336:          		}
1337:          #endif
1338:          #ifdef	PRECISION
1339:          		if(c < prec)
1340:          			c = prec;
1341:          		else if(prec < c)
1342:          			prec = c;
1343:          #endif
1344:          #if	defined(WIDTH) && defined(NEGSIGN)
1345:          		if(width && flag & NEGSIGN)
1346:          			width--;
1347:          #ifdef	PRECISION
1348:          		if(flag & PRECISION) {
1349:          			if(width > prec)
1350:          				width -= prec;
1351:          			else
1352:          				width = 0;
1353:          		}
1354:          #endif
1355:          #ifdef	ALTERN
1356:          #ifdef	EIGHT
1357:          		if((flag & (
1358:          #ifdef	FILL
1359:          						FILL|
1360:          #endif
1361:          							BASEM|ALTERN)) == (EIGHT|ALTERN)) {
1362:          			if(width)
1363:          				width--;
1364:          		} else
1365:          #endif	// EIGHT
1366:          #if	defined(SIXTEEN)
1367:          #ifdef	BASEM
1368:          		if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1369:          #else
1370:          		if(flag & ALTERN) {
1371:          #endif
1372:          			if(width > 2)
1373:          				width -= 2;
1374:          			else
1375:          				width = 0;
1376:          		}
1377:          #endif	// SIXTEEN
1378:          #endif	// ALTERN
1379:          #endif	// WIDTH
1380:          #ifdef	WIDTH
1381:          		if(width > c)
0917  0833     MOVF r, W
0918  00A7     MOVWF 0x27
0919  01A8     CLRF 0x28
091A  1BA7     BTFSC 0x27, 0x7
091B  03A8     DECF 0x28, F
091C  0828     MOVF 0x28, W
091D  3A80     XORLW 0x80
091E  00A9     MOVWF r
091F  0832     MOVF c, W
0920  3A80     XORLW 0x80
0921  0229     SUBWF r, W
0922  1D03     BTFSS STATUS, 0x2
0923  2926     GOTO 0x126
0924  0831     MOVF width, W
0925  0227     SUBWF 0x27, W
0926  1803     BTFSC STATUS, 0x0
0927  2932     GOTO 0x132
1382:          			width -= c;
0928  0020     MOVLB 0x0
0929  0833     MOVF r, W
092A  00A7     MOVWF 0x27
092B  01A8     CLRF 0x28
092C  1BA7     BTFSC 0x27, 0x7
092D  03A8     DECF 0x28, F
092E  02B1     SUBWF width, F
092F  0828     MOVF 0x28, W
0930  3BB2     SUBWFB c, F
0931  2935     GOTO 0x135
1383:          		else
1384:          			width = 0;
0932  0020     MOVLB 0x0
0933  01B1     CLRF width
0934  01B2     CLRF c
1385:          #endif
1386:          #ifdef	FILL
1387:          		if(flag & FILL) {
0935  1D2C     BTFSS flag, 0x2
0936  2944     GOTO 0x144
1388:          #ifdef	MANSIGN
1389:          			if(flag & MANSIGN)
1390:          				putsign();
1391:          #elif defined(NEGSIGN)
1392:          			if(flag & NEGSIGN)
1393:          				pputc('-');
1394:          #endif
1395:          #if defined(MANSIGN) || defined(NEGSIGN) && defined(SPCSIGN)
1396:          			else
1397:          #endif	// MANSIGN
1398:          #ifdef	SPCSIGN
1399:          			if(flag & SPCSIGN)
1400:          				pputc(' ');
1401:          #endif
1402:          #if defined(ALTERN) && defined(SIXTEEN)
1403:          			else if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1404:          				pputc('0');
1405:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1406:          				pputc(flag & UPCASE ? 'X' : 'x');
1407:          #elif defined(HEXUPCASE)
1408:          				pputc('X');
1409:          #else
1410:          				pputc('x');
1411:          #endif	// HEXUPCASE
1412:          			}
1413:          #endif	// ALTERN
1414:          #ifdef	WIDTH
1415:          			if(width)
0937  0831     MOVF width, W
0938  0432     IORWF c, W
0939  1903     BTFSC STATUS, 0x2
093A  2954     GOTO 0x154
1416:          				do
1417:          					pputc('0');
093B  3030     MOVLW 0x30
093C  2182     CALL 0x182
093D  3188     MOVLP 0x8
1418:          				while(--width);
093E  30FF     MOVLW 0xFF
093F  0020     MOVLB 0x0
0940  07B1     ADDWF width, F
0941  1C03     BTFSS STATUS, 0x0
0942  03B2     DECF c, F
0943  2937     GOTO 0x137
1419:          #endif	// WIDTH
1420:          		} else
1421:          #endif	//FILL
1422:          		{
1423:          #ifdef	WIDTH
1424:          			if(width
1425:          #ifdef	LEFT
1426:          					&& !(flag & LEFT)
1427:          #endif
1428:          					)
0944  0831     MOVF width, W
0945  0432     IORWF c, W
0946  1903     BTFSC STATUS, 0x2
0947  2954     GOTO 0x154
1429:          				do
1430:          					pputc(' ');
0948  3020     MOVLW 0x20
0949  2182     CALL 0x182
094A  3188     MOVLP 0x8
1431:          				while(--width);
094B  30FF     MOVLW 0xFF
094C  0020     MOVLB 0x0
094D  07B1     ADDWF width, F
094E  1C03     BTFSS STATUS, 0x0
094F  03B2     DECF c, F
0950  0831     MOVF width, W
0951  0432     IORWF c, W
0952  1D03     BTFSS STATUS, 0x2
0953  2948     GOTO 0x148
1432:          #endif	// WIDTH
1433:          #ifdef	MANSIGN
1434:          			if(flag & MANSIGN)
1435:          				putsign();
1436:          #else
1437:          #ifdef	NEGSIGN
1438:          			if(flag & NEGSIGN)
1439:          				pputc('-');
1440:          #endif
1441:          #endif	// MANSIGN
1442:          #ifdef	SPCSIGN
1443:          			else if(flag & SPCSIGN)
1444:          				pputc(' ');
1445:          #endif
1446:          #ifdef	ALTERN
1447:          #ifdef	EIGHT
1448:          			if((flag & (BASEM|ALTERN)) == (EIGHT|ALTERN))
1449:          				pputc('0');
1450:          			else
1451:          #endif	// EIGHT
1452:          #ifdef	SIXTEEN
1453:          #ifdef	BASEM
1454:          			if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1455:          #else
1456:          			if(flag & ALTERN) {
1457:          #endif
1458:          				pputc('0');
1459:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1460:          				pputc(flag & UPCASE ? 'X' : 'x');
1461:          #elif defined(HEXUPCASE)
1462:          				pputc('X');
1463:          #else
1464:          				pputc('x');
1465:          #endif
1466:          			}
1467:          #endif	// SIXTEEN
1468:          #endif	// ALTERN
1469:          		}
1470:          #if	defined(SIXTEEN) || defined(TEN) || defined(EIGHT) || defined(UNSIGN)
1471:          #ifndef	PRECISION
1472:          		prec = c;
0954  0833     MOVF r, W
0955  00B0     MOVWF i
1473:          #endif
1474:          		while(prec--) {
0956  297C     GOTO 0x17C
097C  0020     MOVLB 0x0
097D  03B0     DECF i, F
097E  0F30     INCFSZ i, W
097F  2957     GOTO 0x157
1475:          #ifdef	MULTRAD
1476:          			switch((unsigned char)(flag & BASEM))
1477:          #endif
1478:          			{
1479:          
1480:          #if	defined(TEN) || defined(UNSIGN)
1481:          #ifdef	MULTRAD
1482:          #ifdef	TEN
1483:          		case TEN:
1484:          #endif
1485:          #ifdef	UNSIGN
1486:          		case UNSIGN:
1487:          #endif
1488:          #endif	// MULTRAD
1489:          				c = (val / dpowers[prec]) % 10 + '0';
1490:          #ifdef	MULTRAD
1491:          				break;
1492:          #endif
1493:          #endif	// TEN || UNSIGN
1494:          
1495:          #ifdef	SIXTEEN
1496:          #ifdef	MULTRAD
1497:          			case SIXTEEN:
1498:          #endif
1499:          			{
1500:          				unsigned char idx = (val / hexpowers[prec]) & 0xF;
0957  082F     MOVF 0x2F, W
0958  00F6     MOVWF 0x76
0959  082E     MOVF val, W
095A  00F5     MOVWF s
095B  0830     MOVF i, W
095C  00A7     MOVWF 0x27
095D  3000     MOVLW 0x0
095E  01A8     CLRF 0x28
095F  35A7     LSLF 0x27, F
0960  0DA8     RLF 0x28, F
0961  0727     ADDWF 0x27, W
0962  0084     MOVWF FSR0
0963  3090     MOVLW 0x90
0964  3D28     ADDWFC 0x28, W
0965  0085     MOVWF FSR0H
0966  3F00     MOVIW [0]FSR0
0967  00F3     MOVWF state
0968  3F01     MOVIW [1]FSR0
0969  00F4     MOVWF stereo
096A  3185     MOVLP 0x5
096B  2537     CALL 0x537
096C  3188     MOVLP 0x8
096D  0873     MOVF state, W
096E  00AD     MOVWF idx
096F  300F     MOVLW 0xF
0970  05AD     ANDWF idx, F
1501:          #if	defined(HEXLOWCASE) && defined(HEXUPCASE)
1502:          				c = (flag & UPCASE ? "0123456789ABCDEF" : "0123456789abcdef")[idx];
1503:          #elif	defined(HEXUPCASE)
1504:          				c = "0123456789ABCDEF"[idx];
1505:          #else
1506:          				c = "0123456789abcdef"[idx];
0971  082D     MOVF idx, W
0972  3E59     ADDLW 0x59
0973  0084     MOVWF FSR0
0974  3090     MOVLW 0x90
0975  1803     BTFSC STATUS, 0x0
0976  3E01     ADDLW 0x1
0977  0085     MOVWF FSR0H
0978  0800     MOVF INDF0, W
0979  00B3     MOVWF r
1507:          #endif	//HEXCASE
1508:          			}
1509:          #ifdef	MULTRAD
1510:          				break;
1511:          #endif
1512:          #endif
1513:          
1514:          #ifdef	EIGHT
1515:          #ifdef	MULTRAD
1516:          			case EIGHT:
1517:          #endif	// MULTRAD
1518:          				c = ((val / octpowers[prec]) & 07) + '0';
1519:          #ifdef	MULTRAD
1520:          				break;
1521:          #endif	// MULTRAD
1522:          #endif	// EIGHT
1523:          			}
1524:          			pputc(c);
097A  2182     CALL 0x182
097B  3188     MOVLP 0x8
1525:          		}
1526:          #endif	// 16 or 10 or 8
1527:          #ifdef	LEFT
1528:          		if((flag & LEFT) && width > 0)
1529:          			do
1530:          				pputc(' ');
1531:          			while(--width);
1532:          #endif	// LEFT
1533:          	}
1534:          #ifdef	ANYFORMAT
1535:          alldone:
1536:          #endif	// ANYFORMAT
1537:          #if	!defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF))
1538:          	*sp = 0;
1539:          #endif
1540:          	return ccnt;
1541:          }
0981  0008     RETURN
1542:          
---  /Applications/microchip/xc8/v1.35/sources/common/cputs.c  ------------------------------------------
1:             #include	<conio.h>
2:             
3:             void
4:             cputs(const char * s)
5:             {
6:             	while(*s)
0579  0875     MOVF s, W
057A  0084     MOVWF FSR0
057B  0876     MOVF 0x76, W
057C  0085     MOVWF FSR0H
057D  0012     MOVIW FSR0++
057E  1903     BTFSC STATUS, 0x2
057F  0008     RETURN
058B  2D79     GOTO 0x579
7:             		putch(*s++);
0580  0875     MOVF s, W
0581  0084     MOVWF FSR0
0582  0876     MOVF 0x76, W
0583  0085     MOVWF FSR0H
0584  0800     MOVF INDF0, W
0585  3189     MOVLP 0x9
0586  2182     CALL 0x182
0587  3185     MOVLP 0x5
0588  0AF5     INCF s, F
0589  1903     BTFSC STATUS, 0x2
058A  0AF6     INCF 0x76, F
058B  2D79     GOTO 0x579
8:             }
---  /Applications/microchip/xc8/v1.35/sources/common/Umul32.c  -----------------------------------------
1:             // 32 x 32 bit multiplication with 32 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned long
15:            __lmul(unsigned long multiplier, unsigned long multiplicand)
16:            {
17:            	unsigned long product;
18:            
19:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:            #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:            #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:            
24:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:            	{
26:            
27:            #define USE_SHRINK
28:            
29:            /*
30:            a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                         a  b  c  d
32:            *            e  f  g  h
33:            -----------------------
34:                       |         dh
35:                       |      ch  0
36:                       |   bh  0  0
37:                       |ah  0  0  0
38:                       |      dg  0
39:                       |   cg  0  0
40:                       |bg  0  0  0
41:                     ag| 0  0  0  0 (we ignore this intermediate product
42:                                     because it does not affect the low 32 bits of the result)
43:                       |   df  0  0
44:                       |cf  0  0  0
45:                     bf| 0  0  0  0 (ignore)
46:                  af  0| 0  0  0  0 (ignore)
47:                       |de  0  0  0
48:                     ce| 0  0  0  0 (ignore)
49:                  be  0| 0  0  0  0 (ignore)
50:            +  ae  0  0| 0  0  0  0 (ignore)
51:            =======================
52:             */
53:            		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:            
55:            #if defined(USE_MASKS)
56:            		product += ((unsigned long)
57:            			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:            			     +
59:            			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:            			<< 8;
61:            
62:            		product += ((unsigned long)
63:            			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:            			    +
65:            			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:            			    +
67:            			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:            			<< 16;
69:            
70:            		/* cast to smaller type to avoid adding high bits just to discard */
71:            		product += ((unsigned long)
72:            			    (unsigned char)
73:            			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:            			    +
75:            			    (unsigned char)
76:            			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:            			    +
78:            			    (unsigned char)
79:            			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:            			    +
81:            			    (unsigned char)
82:            			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:            			<< 24;
84:            
85:            #elif defined(USE_SHRINK)
86:            		/* add direct to upper bytes, rather than shift and add all bytes */
87:            		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:            			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:            		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:            			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:            
92:            
93:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:            			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:            			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:            			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:            
100:           		*(((unsigned char*)&product)+3) +=
101:           			(unsigned char)
102:           			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:           		*(((unsigned char*)&product)+3) +=
104:           			(unsigned char)
105:           			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:           		*(((unsigned char*)&product)+3) +=
107:           			(unsigned char)
108:           			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:           		*(((unsigned char*)&product)+3) +=
110:           			(unsigned char)
111:           			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:           
113:           #else
114:           #error No method chosen
115:           #endif
116:           	}
117:           #else
118:           
119:           	product = 0;
0FC2  01F3     CLRF state
0FC3  01F4     CLRF stereo
0FC4  01F5     CLRF s
0FC5  01F6     CLRF 0x76
120:           	do {
121:           		if(multiplier & 1)
0FC6  1C20     BTFSS __pcstackBANK0, 0x0
0FC7  2FD0     GOTO 0x7D0
122:           			product += multiplicand;
0FC8  0824     MOVF n, W
0FC9  07F3     ADDWF state, F
0FCA  0825     MOVF 0x25, W
0FCB  3DF4     ADDWFC stereo, F
0FCC  0826     MOVF a, W
0FCD  3DF5     ADDWFC s, F
0FCE  0827     MOVF 0x27, W
0FCF  3DF6     ADDWFC 0x76, F
123:           		multiplicand <<= 1;
0FD0  35A4     LSLF n, F
0FD1  0DA5     RLF 0x25, F
0FD2  0DA6     RLF a, F
0FD3  0DA7     RLF 0x27, F
124:           		multiplier >>= 1;
0FD4  36A3     LSRF f, F
0FD5  0CA2     RRF s2, F
0FD6  0CA1     RRF quotient, F
0FD7  0CA0     RRF __pcstackBANK0, F
125:           	} while(multiplier != 0);
0FD8  0823     MOVF f, W
0FD9  0422     IORWF s2, W
0FDA  0421     IORWF quotient, W
0FDB  0420     IORWF __pcstackBANK0, W
0FDC  1D03     BTFSS STATUS, 0x2
0FDD  2FC6     GOTO 0x7C6
126:           
127:           #endif
128:           	return product;
0FDE  0876     MOVF 0x76, W
0FDF  00A3     MOVWF f
0FE0  0875     MOVF s, W
0FE1  00A2     MOVWF s2
0FE2  0874     MOVF stereo, W
0FE3  00A1     MOVWF quotient
0FE4  0873     MOVF state, W
0FE5  00A0     MOVWF __pcstackBANK0
129:           }
0FE6  0008     RETURN
---  /Applications/microchip/xc8/v1.35/sources/common/Umul16.c  -----------------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:            
41:            #else
42:            
43:            	product = 0;
0410  0020     MOVLB 0x0
0411  01A0     CLRF __pcstackBANK0
0412  01A1     CLRF quotient
44:            	do {
45:            		if(multiplier & 1)
0413  1C73     BTFSS state, 0x0
0414  2C1A     GOTO 0x41A
46:            			product += multiplicand;
0415  0875     MOVF s, W
0416  0020     MOVLB 0x0
0417  07A0     ADDWF __pcstackBANK0, F
0418  0876     MOVF 0x76, W
0419  3DA1     ADDWFC quotient, F
47:            		multiplicand <<= 1;
041A  35F5     LSLF s, F
041B  0DF6     RLF 0x76, F
48:            		multiplier >>= 1;
041C  36F4     LSRF stereo, F
041D  0CF3     RRF state, F
49:            	} while(multiplier != 0);
041E  0873     MOVF state, W
041F  0474     IORWF stereo, W
0420  1D03     BTFSS STATUS, 0x2
0421  2C13     GOTO 0x413
50:            
51:            #endif
52:                    return product;
0422  0020     MOVLB 0x0
0423  0821     MOVF quotient, W
0424  00F4     MOVWF stereo
0425  0820     MOVF __pcstackBANK0, W
0426  00F3     MOVWF state
53:            }
0427  0008     RETURN
